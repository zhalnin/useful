/**
 * Created by JetBrains PhpStorm.
 * User: zhalnin
 * Date: 08.04.12
 * Time: 14:44
 * To change this template use File | Settings | File Templates.
 */



/*
Осуществляет задачи, связанные с использованием AJAX
ajax( options )
httpSuccess( r )
httpData ( r, type )

Сериализация структур данных в совместимую с HTTP схему параметров AJAX
serialize( a )

Определение высоты и ширины области просмотра браузера
windowHeight()
windowWidth()

Корректировка позиции области просмотра браузера
scrollTo( 0, 0 )

Определение, где находится область просмотра относительно верхенй части документа
scrollX()
scrollY()

Определение длины и ширины текущей веб-страницы
pageHeight()
pageWidth()

Получение позиции указателя мыши относительно текущего элемента
getElementX( e )
getElementY( e )

Получение ткущей позиции указателя мыши относительно всего пространства страницы
getX( e )
getY( e )

Медленное проявление скрытого элемента за счет увеличения в течение секунды его прозрачности
fadeIn( elem, to, speed )
fadeOut( elem , to, speed )

Медленное появление скрытого элемента за счет увеличения его высоты в течение секунды
slideDown( elem )

Переключение видимости элемента с использованием его CSS-свойства display
hide( elem )
show( elem )

Получение полной потенциональной высоты или ширины элемента, даже если он скрыт
fullHeight( elem )
fullWidth( elem )

Извлечение текущей высоты или ширины DOM-элемента
getHeight( elem )
getWidth( elem )

Установка позиции элемента относительно его текущей позиции
addX( elem, pos )
addY( elem, pos )

Установка X и Y позиций элемента, независимо от его текущей позиции
setX( elem, pos )
setY( elem, pos )

Определение CSS-позиционирования элемента
posX( elem )
posY( elem )

Определение горизонтальной позиции элемента внутри его родителя
parentX( elem )
parentY( elem )

Определение местоположения элемента (x и y) относительно всего документа
pageX( elem )
pageY( elem )

Получение свойства style (name) определенного элемента (elem)
getStyle( elem, name)

Класс доступности javascript

Предотвращение исходных действий браузера
stopDefault( e )

Остановка всплытия события
stopBubble( e )

Создане нового DOM-элемента
create( elem )

Добавление элемента
append( parent, elem )
before( parent, before, elem )
checkElem( e )

Удаление узла
remove( elem )

Удаление всех дочерних узлов
empty( elem )

Установка и получение значений атрибутов элементов
attr( elem, name, value )

Обработка DOM элементов
prev( elem )
next( elem )
first( elem )
last( elem )
parent( elem, num )

Упаковка getElementById
id( elem )

Упаковка getElementsByTagName
tag( name, elem )

Поиск всех элементов + классов
hasClass( name, type )

Добавление класса элементу
addClass( name, type )

Удаление класса элемента
removeClass( name, type )

Извлечение текстового содержимого из элемента
text( e )

Определение наличия у элемента атрибута
hasAttributes( elem, name )

Готовность DOM
domReady( f )
isDOMReady()

Библиотека addEvent/removeEven
addEvent( elem, type, handler )
removeEvent( elem, type, handler )
handleEvent( event )
fixEvent( event )
*/

///////////////////////////////////////////////////////////////////////
//  Для осуществления AJAX-запросов                                  //
// принимает одни аргумент, представляющий собой объект, содержащий  //
// набор параметров                                                  //
///////////////////////////////////////////////////////////////////////
function ajax( options )
{
    // Загрузка объекта параметров по умолчанию, если пользователь не
    // представил никаких значений
    options =
    {
        // Режим http-запроса
        type: options.mode || "POST",
        // URL на который должен быть послан запрос
        url: options.url || "",
        // Время ожидания ответа на запрос
        timeout: options.timeout || 5000,
        // Функция, вызываемая, когда запрос неудачен, успешен
        // или завершен (успешно или нет)
        onComplete: options.onComplete || function(){},
        onError: options.onError || function(){},
        onSuccess: options.onSuccess || function(){},
        // Тип данных, которые будут возвращены с сервера
        // по умолчанию просто определить, какие данные были
        // возвращены, и действовать соответственно
        data: options.data || ""
    };
    // Создание объекта запроса
    var xml = new XMLHttpRequest();
    // Открытие асинхронного запроса
    xml.open(options.type, options.url, true);
    // Ожидание отклика на запрос в течение 5 секунд
    // перед тем, как от него отказаться

    var timeoutLength = options.timeout;
    // Отслеживание факта успешного завершения запроса
    var requestDone = false;
    // Инициализация функции обратного вызова, которая будет запущена через
    // 5 секунд, отменяя запрос (если он не будет к тому времени выполнен)
    setTimeout(function()
    {
        requestDone = true;
    }, timeoutLength);

    // Отслеживание обновления состояния документа
    xml.onreadystatechange = function()
    {
        // Ожидание, полной загрузки данных
        // и проверки, не истекло ли время запроса
        if(xml.readyState == 4 && !requestDone)
        {
            // Проверка успешности запроса
            if(httpSuccess(xml))
            {
                // Выполнение в случае успеха функции обратного вызова
                // с данными, возвращенными с сервера
                options.onSuccess(httpData(xml, options.data));
            }
            else
            {
                // В противном случае призошла ошибка, поэтому нужно
                // выполнить функцию обратного вызова для обработки ошибки
                options.onError();
            }
            // Выполнение функции обратного вызова, связанной с завершением
            // запроса
            options.onComplete();
            // Подчистка соединения с сервером
            xml = null;
        }
    };

    // Установка соединения с сервером
    xml.send();

    // Определение успешности получения ответа HTTP
    function httpSuccess(r)
    {
        try
        {
            // Если состояние сервера предоставлено не было, и мы
            // фактически сделали запрос к локальному файлу,
            // значит, он прошел успешно
            return !r.status && location.protocol == "file:" ||
                // нас устраивает любой код состояния в диапазоне 200
                (r.status >=200 && r.status < 300) ||
                // запрос прошел успешно, если документ не подвергся
                // изменениям
                r.status == 304 ||
                // если файл не подвергался изменениям, Safari возвращает
                // пустое состояние
                navigator.userAgent.indexOf("Safari") >= 0
                    && typeof r.status == "undefined";
        }
        catch(e){}
        // Если проверка состояния не удалась, следует предположить,
        // что запрос тоже закончился неудачей
        return false;
    }

    // Извлечение правильных данных из ответа HTTP
    function httpData(r, type)
    {
        // Получение заголовка content-type
        var ct = r.getResponseHeader("content-type");
        // Если не предоставлен тип по умолчанию, определение
        // не возвращена ли с сервера какая-либо форма XML
        var data = !type && ct && ct.indexOf("xml") >= 0;
        // Получение объекта XML-документа, если сервер вернул XML,
        // если нет - возвращение полученного с сервера текстового
        // содержимого
        data = type == "xml" || data ? r.responseXML : r.responseText;
        // Если указан тип "script", выполнение возвращенного текста,
        // реагируя на него, как на JavaScript
        if(type == "script")
            eval.call(window, data);
        // Возвращение данных, полученных в ответе
        return data;
    }
}
///////////////////////////////////////////////////////////////////////
//                                                                   //
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
// Сериализация набора данных AJAX                                   //
///////////////////////////////////////////////////////////////////////
// Может воспринимать два различных пипа объектов:
// - массив элементов ввода
// - хэш, составленный из пар ключ-значение
// Функция возвращает последовательную строку данных
function serialize(a)
{
    // Набор результатов сериализации
    var s = [];
    // Если передан массив, предположение, что он является массивом
    // элементов формы
    if(a.constructor == Array)
    {
        // Сериализация элементов формы
        for(var i = 0; i < a.length; i++)
            s.push(a[i].name + "=" + encodeURIComponent(a[i].value));
    // Если нет, предположение, что это объект, состоящий
    // из пар ключ-значение
    }
    else
    {
        // Сериализация пар ключ-значение
        for(var j in a)
            s.push(j+ "=" + encodeURIComponent(a[j]));
    }
    // возврат результатов сериализации
    return s.join("&");
}
///////////////////////////////////////////////////////////////////////
//                                                                   //
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
// Определение высоты и ширины области просмотра браузера            //
///////////////////////////////////////////////////////////////////////
// Определение высоты области просмотра
function windowHeight()
{
    // Сокращение на случай использования IE6 в строгом
    // (strict) режиме
    var de = document.documentElement;

    // Использование свойства браузера innerHeight, если оно доступно
    return self.innerHeight ||
        // в противном случае попытка получить высоту из корневого узла
        ( de && de.clientHeight ) ||
        // И наконец, попытка получить высоту из элемента body
        document.body.clientHeight;
}
// Определение ширины области просмотра
function windowWidth()
{
    // Сокращение на случай испльзования IE6 в строгом
    // (strict) режиме
    var de = document.documentElement;

    // Использование свойства браузера innerWidth, если оно доступно
    return self.innerWidth ||
        // в противном случае попытка получить ширину из корневого узла
        (de && de.clientWidth) ||
        // И наконец, попытка получить высоту из элемента body
        document.body.clientWidth;
}
///////////////////////////////////////////////////////////////////////
//                                                                   //
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
// Определение, где находится область просмотра относительно         //
// верхенй части документа                                           //
///////////////////////////////////////////////////////////////////////
// Функция для определения величины горизонтальной прокрутки браузера
function scrollX()
{
    // Сокращение на случай использования IE6 в строгом
    // (strict)режиме
    var de = document.documentElement;

    // Использование свойства браузера pageXOffset, если оно доступно
    return self.pageXOffset ||
        // в противном случае попытка получить прокрутку слева из
        // корневого узла
        (de && de.scrollLeft) ||
        // и наконец, попытка получить прокурутку слева из элемента body
    document.body.scrollLeft;
}
// Определение величины вертикальной прокрутки браузера
function scrollY()
{
    // Сокращение на случай использования IE6 в строгом
    // (strict) режиме
    var de = document.documentElement;

    // Использование свойства браузера pageYOffset, если оно доступно
    return self.pageYOffset ||
        // в противном случае попытка получить прокрутку сверху из
        // корневого узла
        ( de && de.scrollTop ) ||
        // и наконец, попытка получить прокрутку сверху из элемента body
        document.body.scrollTop;
}
///////////////////////////////////////////////////////////////////////
//                                                                   //
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
// Определение длины и ширины текущей веб-страницы                   //
///////////////////////////////////////////////////////////////////////
// Возвращение высоты веб-страницы
// может изменяться при добавлении к странице нового содержимого
function pageHeight()
{
    return document.body.scrollHeight;
}
// Возвращение ширины веб-страницы
function pageWidth()
{
    return  document.body.scrollWidth;
}
///////////////////////////////////////////////////////////////////////
//                                                                   //
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
// Получение позиции указателя мыши относительно текущего элемента   //
///////////////////////////////////////////////////////////////////////
// Получение X-позиции указателя относительно целевого элемента,
// который используется в объекте события 'е'
function  getElementX(e)
{
    // Определение соответствующего смещения элемента
    return ( e && e.layerX )|| window.event.offsetX;
}

// Получение Y-позиции куазателя относительно целевого элемента,
// который используется в объекте события 'е'
function getElementY(e)
{
    // Определение соответствующего смещения элемента
    return ( e && e.layerY )|| window.event.offsetY;
}
///////////////////////////////////////////////////////////////////////
//                                                                   //
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
// Получение указателя мыши относительно всего                       //
// пространства страницы                                             //
///////////////////////////////////////////////////////////////////////
// Получение горизонтальной позиции указателя
function getX(e)
{
    // Нормализация объекта события
    e = e || window.event;

    // Сначала получение позиции из браузеров, не относящихся к IE,
    // а затем из IE
    return e.pageX || e.clientX + document.body.scrollLeft;
}

// Получение вертикальной позиции указателя
function getY(e)
{
    // Нормализация объекта
    e = e || window.event;

    // Сначала получение позиции из браузеров, не относящихся к IE,
    // затем из IE
    return e.pageY || e.clientY + document.body.scrollTop;
}
///////////////////////////////////////////////////////////////////////
//                                                                   //
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
// Медленное проявление скрытого элемента за счет увеличения         //
// в течение секунды его непрозрачности                              //
///////////////////////////////////////////////////////////////////////
function fadeIn( elem, to, speed )
{
    // Начало непрозрачности с 0
    setOpacity(elem, 0);
    // Отображение элемента ( но вы его не увидите, пока непрозрачность
    // равна 0)
    show( elem );
    // Мы собираем я за секунду показать анимацию, состоящую из
    // 20 "кадров"
    for( var i = 0; i <= 100; i+=5)
    {
//        alert("i - "+i);
        // Замкнутое выражение, гарантирующее, что у нас в распоряжении
        // находится именно та переменная 'i', которая нам нужна
        (function()
        {
            var opacity = i;
//            alert("pos - "+opacity);
            // Установка времени ожидания для совершения будущих
            //  действий в определенное время
            setTimeout(function()
            {
//                alert("second i - "+i);
//                alert("second pos - "+opacity);
                // Установка новой степени прозрачности элемента
                setOpacity( elem, (opacity / 100) * to );
            }, (i + 1) * speed);
        })();
    }
}
///////////////////////////////////////////////////////////////////////
//                                                                   //
///////////////////////////////////////////////////////////////////////


function fadeOut( elem, to, speed )
{
    // Начало непрозрачности с 1
//    setOpacity(elem, 1);
    // Отображение элемента ( но вы его не увидите, пока непрозрачность
    // равна 0)
//    hide( elem );

    // Мы собираемся за секунду показать анимацию, состоящую из
    // 20 "кадров"
    for( var i = 0; i < 0; i+=5)
    {
        console.log(i);
        // Замкнутое выражение, гарантирующее, что у нас в распоряжении
        // находится именно та переменная 'i', которая нам нужна
        (function()
        {
            var opacity = i;
            console.log("first pos - "+opacity);
//            console.log(pos);
            // Установка времени ожидания для совершения будущих
            //  действий в определенное время
            setTimeout(function()
            {
                // Установка новой степени прозрачности элемента
                console.log("p - "+p);
                
                setOpacity( elem, 100 - opacity );
                if(opacity == 95)
                    hide( elem );
            }, (i + 1) * speed);
        })();
    }
}











///////////////////////////////////////////////////////////////////////
//  Медленное появление скрытого элемента за счет увеличения         //
//  его высоты в течение секунды                                     //
///////////////////////////////////////////////////////////////////////
function slideDown( elem )
{
    // Начало выплывания вниз с 0
    elem.style.height = '0px';

    // Показ элемента ( но вы его не увидите, пока высота равна 0)
    show( elem );

    // Определение полной, потенциальной высоты элемента
    var h = fullHeight( elem );

    // Мы собираемся за секунду показать анимацию, состоящую из
    // 20 кадров
    for( var i = 0; i <= 100; i += 5)
    {
        // Замкнутое выражение, гарантирующее, что у нас в паспоряжении
        // находится именно та переменная 'i', которая нам нужна
        (function()
        {
            var pos = i;

            // Установка времени ожидания для совершения будущих
            // действий в определенное время
            setTimeout(function()
            {
                // Установка новой высоты элемента
                elem.style.height = ( pos / 100 ) * h + "px";

            }, ( pos + 1 ) * 10);
        })();
    }
}
///////////////////////////////////////////////////////////////////////
//                                                                   //
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//  Корректировка уровня прозрачности элемента                       //
///////////////////////////////////////////////////////////////////////
// Установка уровня прозрачности элемента
// где уровень является числом в диапазоне 0 - 100
function setOpacity( elem, level )
{
    // Если существуют какие-нибудь фильтры, значит,
    // мы имеем дело с IE, и нужно устанавливать фильта Alpha
    if( elem.filters )
    {
        alert(elem);
//        elem.filters.alpha.opacity = level;
        elem.style.filters = 'alpha(opacity='+ level + ')';

    }



    // В противном случае мы используем W3C-свойство opacity
    else
        elem.style.opacity = level / 100;
}
///////////////////////////////////////////////////////////////////////
//                                                                   //
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//  Переключение видимости элемента с использованием его CSS-свойства//
// display                                                           //
///////////////////////////////////////////////////////////////////////
// Функция для скрытия элемента (с использованием свойства display)
function hide( elem )
{
    // Определение текущего состояния свойства display
    var curDisplay = getStyle( elem, 'display');

    // Запоминание состояния свойства display на будущее
    if( curDisplay != 'none' )
        elem.$oldDisplay = curDisplay;

    // Установка display в none (сокрытие элемента)
    elem.style.display = 'none';
}
// Функция показа элемента (с использование свойства display)
function show( elem )
{
    // Возвращение свойства display к тому значеню, которое им
    // использовалось, или использование
    // 'block', если предыдущее состояние этого свойства не было
    // сохранено
    elem.style.display = elem.$oldDisplay || 'block';
}
///////////////////////////////////////////////////////////////////////
//                                                                   //
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
// Получение полной потенциональной высоты или ширины элемента,      //
// даже если он скрыт                                                //
///////////////////////////////////////////////////////////////////////
// Получение полной возможной высоты элемента ( в отличие от фактической
// текущей высоты )
function fullHeight( elem )
{
    // Если элемент отображен на экране, то сработает свойство
    // offsetHeight, а если оно не сработает, то сработает getHeight()
    if( getStyle( elem, 'display') != 'none')
        return elem.offsetHeight || getHeight( elem );

    // В противном случае нам придется иметь дело с элементом,
    // у которого display имеет значение none, поэтому
    // нужно переустановить его CSS-свойства, чтобы считать более
    // точный результат
    var old = resetCSS( elem,
        {
           display: '',
            visibility: 'hidden',
            position: 'absolute'
        });

    // Определяем полную высоту элемента, используя clientHeight,
    // а если это свойство не работает, используем getHeight
    var h = elem.clientHeight || getHeight( elem );

    // В завершение восстанавливаем прежние CSS-свойства
    restoreCSS( elem, old );

    // и возвращаем полную высоту элемента
    return h;
}

// Получение полной возможной ширины элемента ( в отличие от фактической
// текущей ширины )
function fullWidth( elem )
{
    // Если элемент отображен на экране, то сработает свойство
    // offsetWidth а если оно не сработает, то сработает getWidth()
    if( getStyle( elem, 'display') != 'none' )
        return elem.offsetWidth || getWidth( elem );
    // В противном случае нам предется иметь дело с элементом,
    // у которого display имеет значение none, поэтому
    // нужно переустановить его CSS-свойства, чтобы считать более
    // точный результат
    var old = resetCSS( elem,
        {
           display: '',
            visibility: 'hidden',
            position: 'absolute'
        });
    // Определяем полную ширину элемента, используя clientWidth,
    // а если это свойство не работает, используем getWidth
    var w = elem.clientWidth || getWidth( elem );
    // В завершение восстанавливаем прежние CSS-свойства
    restoreCSS( elem, old );
    // и возвращаем полную ширину элемента
    return w;
}

// Функция, используемая для переустановки наора CSS-свойств, которые
// позже можно будет восстановить
function resetCSS( elem, prop )
{
    var old = {};
    // Перебор всех свойств
    for( var i in prop )
    {
        // Запоминание старых значений свойств
        old[ i ] = elem.style[ i ];
        // и установка новых значений
        elem.style[ i ] = prop[i];
    }
    // возвращение набора значений для использования в функции restoreCSS
    return old;
}

// Функция для устранения побочных эффектов функции resetCSS
function restoreCSS( elem, prop )
{
    // Переустановка всех свойств и возвращение им первоначальных значений
    for( var i in prop )
        elem.style[ i ] = prop[i];
}
///////////////////////////////////////////////////////////////////////
//                                                                   //
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
// Извлечение текущей высоты или ширины DOM-элемента                 //
///////////////////////////////////////////////////////////////////////
// Получение текущей высоты элемента(с использованием вычисляемого CSS
function getHeight( elem )
{
    // Получение вычисялемого значения CSS и извлечения необходимого
    // числового значения
    return parseInt( getStyle( elem, 'height' ));
}
// Получение текущей ширины элемента ( с использованием вычисляемого CSS)
function getWidth( elem )
{
    // Получение вычисляемого значения CSS и извлечение необходимого
    // числового значения
    return parseInt( getStyle( elem, 'width' ));
}
///////////////////////////////////////////////////////////////////////
//                                                                   //
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//  Установка позиции элемента относительно его текущей позиции      //
///////////////////////////////////////////////////////////////////////
// Функция добавления пикселов к горизонтальной позиции элемента
function addX( elem, pos )
{
    // Получение текущей горизонтальной позиции и добавление к ней
    // смещения
    setX( elem, posX( elem ) + pos);
}
// Функция добавления писелов к вертикальной позиции элемента
function addY( elem, pos )
{
    // Получение текущей вертикальной позиции и добавление к ней
    // мещения
    setY( elem, posY( elem ) + pos);
}
///////////////////////////////////////////////////////////////////////
//                                                                   //
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//  Установка X и Y позиций элемента, независимо от текущей позиции  //
///////////////////////////////////////////////////////////////////////
// Установка горизонтальной позиции элемента
function setX( elem, pos )
{
    // Установка CSS-свойства 'left' с использование единицы измерения,
    // выраженной в пикселах
    elem.style.left = pos + "px";
}
// Установка вертикальной позиции элемента
function setY( elem, pos )
{
    // Установка CSS-свойства 'top' с использованием единицы измерения,
    // выраженной в пикселах
    elem.style.top = pos + "px";
}
///////////////////////////////////////////////////////////////////////
//                                                                   //
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
// Определение CSS-позиционирования элемента                         //
///////////////////////////////////////////////////////////////////////
// Определение левой позиции элемента
function posX( elem )
{
    // Получение вычисляемого значения style и извлечение числа из значения
    return parseInt( getStyle( elem, "left" ));
}
// Определение верхней позиции элемента
function posY( elem )
{
    // Получение вычисляемого значения style и извлечение числа из значения
    return parseInt( getStyle( elem, "top" ));
}
///////////////////////////////////////////////////////////////////////
//                                                                   //
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
// Определение горизонтальной позиции элемента внутри его родителя   //
///////////////////////////////////////////////////////////////////////
// Определение горизонтальной позиции элемента внутри его родителя
function parentX( elem )
{
    // Если offsetParent указывает на родителя элемента, то ранее
    // завершение работы
    return elem.parentNode == elem.offsetParent ?
        elem.offsetLeft:
        // В противном случае нужно найти позицию относительно всей страницы
        // для обоих элементов и вычислить разницу
        pageX( elem ) - pageX( elem.parentNode );
}
// Определение вертикальной позиции элемента внутри его родителя
function parentY( elem )
{
    // Если offsetParent указывает на родителя элемента, то ранее
    // завершение работы
    return elem.parentNode == elem.offsetParent ?
        elem.offsetTop :
        // В противном случае нужно найти позицию относительно всей страницы
        // для обоих элементов и вычислить разницу
        pageY( elem ) - pageY( elem.parentNode);
    
}
///////////////////////////////////////////////////////////////////////
//                                                                   //
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
// Определение местоположения элемента (x и y)                       //
///////////////////////////////////////////////////////////////////////
// Определение X (горизонтальной слева) позиции элемента
function pageX( elem )
{
    // Проверка на достижение корневого элемента
    return elem.offsetParent ?
        // Если не дошли до самого верха, добавление текущего смещения и
        // продолжение движения вверх
        elem.offsetLeft + pageX( elem.offsetParent ) :
        // В противном случае, получение текущего смещения
        elem.offsetLeft;
}
// Определение Y (вертикальной сверху) позиции элемента
function pageY( elem )
{
    // Проверка на достижение корневого элемента
    return elem.offsetParent ?
        // Если не дошли до самого верха, добавление текущего смещения и
        // продолжение движения вверх
        elem.offsetTop + pageY( elem.offsetParent ) :
        // В противном случае, получение текущего смещения
        elem.offsetTop;
}
///////////////////////////////////////////////////////////////////////
//                                                                   //
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//   Получение свойства style( name ) определенного элемента ( elem )//
///////////////////////////////////////////////////////////////////////
function getStyle( elem, name)
{
    // Если свойство присутствует в style[], значит, оно было
    // недавно установлено ( и является теущим)
    if(elem.style[name])
    {
        return elem.style[name];
    }
    // В противном случае, попытка воспользоваться методом IE
    else if(elem.currentStyle)
        return elem.currentStyle[name];

    // Или методом W3C, если он существует
    else if(document.defaultView && document.defaultView.getComputedStyle)
    {
        // Вместо textAlign в нем используется традиционное правило
        // написания стиля - 'text-align'
        name = name.replace(/([A-Z])/g,"-$1");
        name = name.toLowerCase();

        // Получение объекта style и получение значения свойства
        // (если оно существует)
        var s = document.defaultView.getComputedStyle(elem,"");
        return s && s.getPropertyValue(name);

        // В противном случае, мы используем какой-то другой браузер
    }
    else
        return null;
}
///////////////////////////////////////////////////////////////////////
//                                                                   //
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//   Класс доступности javascript                                    //
///////////////////////////////////////////////////////////////////////
//<script>document.documentElement.className = "js";</script>
//<style>.js #fadein { display: none };</style>
//<div id='fadein'>....</div>
///////////////////////////////////////////////////////////////////////
//                                                                   //
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//   Предотвращение исходных действий браузера                       //
///////////////////////////////////////////////////////////////////////
function stopDefault(e)
{
    // Предотвращение исходных действий браузера (W3C)
    if(e && e.preventDefault)
    {
        e.preventDefault();
    }
    else
    {
        // Ссылка на остановку действия браузера в IE
        window.event.returnValue = false;
    }
    return false;
}
///////////////////////////////////////////////////////////////////////
//                                                                   //
///////////////////////////////////////////////////////////////////////



///////////////////////////////////////////////////////////////////////
//  Остановка всплытия события                                       //
///////////////////////////////////////////////////////////////////////
function stopBubble(e)
{
    // Если предоставлен объект события, значит это не IE-браузер
    if(e && e.stopPropagation)
    {
        // и он поддерживает W3C-метод stopPropagation()
        e.stopPropagation();
    }
    else
    {
        // В противном случае нужно воспользоваться способом
        // прекращения всплытия события, существующим в IE
        window.event.cancelBubble = true;
    }
}
///////////////////////////////////////////////////////////////////////
//                                                                   //
///////////////////////////////////////////////////////////////////////



///////////////////////////////////////////////////////////////////////
//  Удаление из DOM отдельного узла                                  //
///////////////////////////////////////////////////////////////////////
function remove( elem )
{
    if(elem) elem.parentNode.removeChild(elem);
}
///////////////////////////////////////////////////////////////////////
//                                                                   //
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//  Удаление из DOM всех дочерних узлов элемента                     //
///////////////////////////////////////////////////////////////////////
function empty(elem)
{
    //console.log(elem.firstChild);
    while(elem.firstChild)
    {
        remove(elem.firstChild);
    }
}
///////////////////////////////////////////////////////////////////////
//                                                                   //
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//  Создание нового DOM-элемента                                     //
///////////////////////////////////////////////////////////////////////
function create( elem )
{
    return document.createElementNS ?
        document.createElementNS('http://www.w3.org/1999/xhtml', elem) :
        document.createElement( elem );
}
///////////////////////////////////////////////////////////////////////
//                                                                   //
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//  Вставка элемента перед другим элементом                          //
///////////////////////////////////////////////////////////////////////
function before(parent, before, elem)
{
    // Выяснение, предоставлен ли родительский (parent) узел
    if(elem == null)
    {
        elem = before;
        before = parent;
        parent = before.parentNode;
    }

    // Получение нового массива элементов
    var elems = checkElem(elem);
    console.log(elems);
    // Обратный перебор элементов массива,
    // поскольку мы добавляем элементы к началу
    for(var i = elems.length - 1; i >= 0; i-- )
    {
        console.log(parent);
        parent.insertBefore(elems[i], before);
    }
}
///////////////////////////////////////////////////////////////////////
//                                                                   //
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//  Добавление элемента в качестве дочернего к другому элементу      //
///////////////////////////////////////////////////////////////////////
function append(parent, elem)
{
    // Получение массива элементов
    var elems = checkElem(elem);

    // Добавление всех элементов к родительскому элементу
    for(var i = 0; i <= elems.length-1; i++)
    {
        parent.appendChild(elems[i]);
    }

}
///////////////////////////////////////////////////////////////////////
//                                                                   //
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//  Вспомогательная для before и append                              //
///////////////////////////////////////////////////////////////////////
function checkElem( a )
{
    //console.log(a);
    var r = [];
    // Превращение аргумента в массив, если он еще им не является
    if( a.constructor != Array ) a = [a];
    //console.log(a);
    for(var i = 0; i < a.length; i++)
    {
        //console.log(a);
        // Если это строка
        if(a[i].constructor == String)
        {
            //console.log("string");
            // Создание временного элемента для помещения в него HTML
            var div = document.createElement("div");

            // Вставка HTML, для превращения его в DOM-структуру
            div.innerHTML = a[i];

            // Обратное извлечение DOM-структуры из временного DIV-элемента
            for(var j = 0; j < div.childNodes.length; j++)
            {
                //console.log(div.childNodes.length);
                r[r.length] = div.childNodes[j];
            }
        }
        else if(a[i].length)
        {
            //console.log("not string");
            // Если это массив DOM-узлов
            for(var j = 0; j < a[i].length; j++)
            {
                r[r.length] = a[i][j];
            }
        }
        else
        {
            //console.log("DOM-node");
            // Иначе, предположение, что это DOM-узел
            r[r.length] = a[i];
            //console.log(r);
        }
    }
    return r;
}
///////////////////////////////////////////////////////////////////////
//                                                                   //
///////////////////////////////////////////////////////////////////////



///////////////////////////////////////////////////////////////////////
//  Установка и получение значений атрибутов элементов               //
///////////////////////////////////////////////////////////////////////
function attr(elem, name, value)
{
    // Гарантирование допустимости предоставленного имени
    if(!name || name.constructor != String) return '';

    // Определение, не относится ли это имя к тем самым "роковым"
    // именам
    name = { 'for':'htmlFor', 'class':'className', 'float':'cssFloat', 'text':'cssText'}[name] || name;

    // Если пользователь устанавливает значение, то также
    if(typeof value != 'undefined')
    {
        // сначала установить быстрый способ
        elem[name] = value;

        // По возмоности воспользоваться setAttribute
        if(elem.setAttribute)
            elem.setAttribute(name, value);
    }

    // Вернуть значение атрибута
    return elem[name] || elem.getAttribute(name) || '';
}
///////////////////////////////////////////////////////////////////////
//                                                                   //
///////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////
//  Функции обработки DOM элементов                             //
//////////////////////////////////////////////////////////////////
// Ищем предыдущий сестринский элемент
function prev(elem)
{
    do
    {
        elem = elem.previousSibling;
    }
    while(elem && elem.nodeType != 1);
    return elem;
}


// Ищем следующий сестринский эелемент
function next(elem)
{
    do
    {
        elem = elem.nextSibling;
    }
    while(elem && elem.nodeType != 1);
    return elem;
}


// Ищем первый дочерний элемент
function first(elem)
{
    elem = elem.firstChild;
    return elem && elem.nodeType != 1 ? next(elem) : elem;
}


// Ищем последний дочерний элемент
function last(elem)
{
    elem = elem.lastChild;
    return elem && elem.nodeType != 1 ? prev(elem) : elem;
}


// Ищем родительский элемент
function parent(elem, num)
{
    num = num || 1;
    for(var i = 0; i < num; i++)
    {
        if(elem != null)
        {
            elem = elem.parentNode;
        }
    }
    return elem;
}
///////////////////////////////////////////////////////////////////////
//                                                                   //
///////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////
//  Функции упаковки getElementById и getElementsByTagName          //
//////////////////////////////////////////////////////////////////////
// Функция для упаковки getElementById
function id(name)
{
    return document.getElementById(name);
}

// Функция обнаружения элементов по имени тега внутри HTML DOM-документа
function tag(name, root)
{
    // Если конкретный элемент не предоставлен, вести поиск по всему
    // документу
    return (root || document).getElementsByTagName(name);
}
///////////////////////////////////////////////////////////////////////
//                                                                   //
///////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////
//  Функции поиска всех элементов hasClass                          //
//////////////////////////////////////////////////////////////////////
function hasClass(name,type)
{
    var r = [];
    // Обнаружение имени класса (работает и при наличии
    // нескольких имен классов
    var re = new RegExp("(^|\\s)"+name+"(\\s|$)");
    // Ограничение поиска элементами определенного типа
    // или поиск по всем элементам
    var e = document.getElementsByTagName(type || "*");
    for(var j = 0; j < e.length; j++)
    {
        // Если элемент имеет нужный класс, добавление его в
        // возвращаемый массив
//        if((e[j]).className.match(re))
//        {
//            r.push(e[j]);
//        }
        if(re.test(e[j].className))
        {
            r.push(e[j]);
        }
    }
    return r;
}
///////////////////////////////////////////////////////////////////////
//                                                                   //
///////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////
// Функция добавления класса элементу                                //
///////////////////////////////////////////////////////////////////////
function addClass(name,type)
{
    if (this.hasClass(name, type) == ''){
        // Ограничение поиска элементами определенного типа
        // или поиск по всем элементам
        var e = typeof type == 'object' ? type : document.getElementsByTagName(type || "*");
        if(e.constructor == HTMLCollection)
        {
            for(var j = 0; j < e.length; j++)
            {
                e[j].className = name;
            }
        }
        else
        {
            e.className = name;
        }
    }
}
///////////////////////////////////////////////////////////////////////
//                                                                   //
///////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////
//  Функция удаления класса из элемента                              //
///////////////////////////////////////////////////////////////////////
function removeClass(name,type)
{
    // Ограничение поиска элементами определенного типа
    // или поиск по всем элементам
    var e = typeof type == 'object' ? type : document.getElementsByTagName(type || "*");
    // Обнаружение имени класса (работает и при наличии
    // нескольких имен классов
    var re = new RegExp("(^|\\s)"+name+"(\\s|$)");
    if(e.constructor == HTMLCollection)
    {
        for(var j = 0; j < e.length; j++)
        {
            if(hasClass(name, e[j])){
                e[j].className = e[j].className.replace(re,'');
            }
        }
    }
    else
    {
        e.className = e.className.replace(re,' ');
    }
}
///////////////////////////////////////////////////////////////////////
//                                                                   //
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//  Функция для извлечения текстового содержимого элементов          //
///////////////////////////////////////////////////////////////////////
function text(e)
{
    var t = "";

    // Если элемент был передан, получение его дочерних элементов
    // иначе, предположение о том, что передан массив
    e = e.childNodes || e;
    // Просмотр всех дочерних узлов
    for(var j = 0; j < e.length; j++)
    {
        // Если это не элемент, присоединить его текстовое значение
        // иначе, провести рекурсивный перебор всех дочерних составляющих
        // элемента
        t += e[j].nodeType != 1 ? e[j].nodeValue : text(e[j].childNodes);

    }
    return t;
}
///////////////////////////////////////////////////////////////////////
//                                                                   //
///////////////////////////////////////////////////////////////////////



///////////////////////////////////////////////////////////////////////
//  Определение наличия у элемента атрибута                          //
///////////////////////////////////////////////////////////////////////
function hasAttributes(elem, name)
{
    return elem.getAttribute(name) != null;
}
///////////////////////////////////////////////////////////////////////
//                                                                   //
///////////////////////////////////////////////////////////////////////




////////////////////////////////////////////////////////////////////
// Готовность DOM                                                 //
////////////////////////////////////////////////////////////////////
// Функция, предназначенная для отслеживания готовности DOM
function domReady(f)
{
    //console.log("1");
    // Если DOM уже загружен, немедленно выполнить функцию
    if(domReady.done)
    {
        //console.log("2");
        return f();
    }

    // Если мы уже дополнили функцию
    if(domReady.timer)
    {
        //console.log("3");
        // внести ее в список исполняемых
        domReady.ready.push(f);
        //console.log("4");
    }
    else
    {
        //console.log("5");
        // Привязывание события завершения загрузки страницы,
        // на тот случай если ее загрузка закончится первой.
        // Здесь используется addEvent.
        addEvent(window, "load", isDOMReady);
        //console.log("6");
        // Инициализация массива иполняемых функций
        domReady.ready = [ f ];
        //console.log("7");
        // Проверка DOM на готовность, проводимая как можно быстрее
        domReady.timer = setInterval(isDOMReady, 13);
        //console.log("8");
    }
}

// Проверка на готовность DOM к перемещению по ее структуре
function isDOMReady()
{
    //console.log("9");
    // Если мы уже определили готовность страницы - проигнорировать
    // дальнейшее выполнение
    if(domReady.done)
    {
        //console.log("10");
        return false;
    }

    // Проверка доступности некоторых функций и элеметов
    if(document && document.getElementsByTagName &&
        document.getElementById && document.body)
    {
        //console.log("11");
        // Если они готовы, можно прекратить проверку
        clearInterval(domReady.timer);
        domReady.timer = null;
        //console.log("12");

        // Выполнение всех ожидавших функций
        for(var i = 0; i < domReady.ready.length; i++)
        {
            //console.log('13');
            domReady.ready[i]();
        }

        //console.log("14");
        // Сохранение того, что только что было сделано
        domReady.ready = null;
        domReady.done = true;
        //console.log("15");
    }
}
///////////////////////////////////////////////////////////////////////
//                                                                   //
///////////////////////////////////////////////////////////////////////




///////////////////////////////////////////////////////////////////////
// Библиотека addEvent/removeEvent                                   //
///////////////////////////////////////////////////////////////////////
// addEvent/removeEvent written by Dean Edwards, 2005
// with input from Tino Zijdel
// http://dian.edwards.name/weblog/2005/10/add-event/

function addEvent(element, type, handler)
{
    //console.log(element, type, handler);
    //console.log("16");
    // присвоение каждому обработчику события уникального ID
    if(!handler.$$guid)
    {
        //console.log('17');
        handler.$$guid = addEvent.guid++;
    }
    //console.log("18");
    // создание хэш-таблицы видов событий для элемента
    if(!element.events)
    {
        element.events = {};
        //console.log('19');
    }

    // создание хэш-таблицы обработчиков событий для каждой пары
    // элемент-событие
    var handlers = element.events[type];
    //console.log("20");
    if(!handlers)
    {
        handlers = element.events[type] = {};
        //console.log('21');
        // сохранение существующего обработчика события
        // (если он существует)
        if(element["on" + type])
        {
            handlers[0] = element["on" + type];
            //console.log("22");
        }
    }

    // сохранение обработчика события в хэш-таблице
    handlers[handler.$$guid] = handler;
    //console.log("23");
    // назначение глобального обработчика события для выполнения
    // всей работы
    element["on" + type] = handleEvent;
    //console.log("24");
};

// счетчик, используемый для создания уникальных ID
addEvent.guid = 1;

function removeEvent(element, type, handler)
{
    //console.log("25");
    // удаление обработчика события из хэш-таблицы
    if(element.events && element.events[type])
    {
        //console.log('26');
        delete element.events[type][handler.$$guid];
    }
};

function handleEvent(event)
{
    //console.log('27');
    var returnValue = true;

    // захват объекта события (IE использует глобальный объект события)
    event = event || fixEvent(window.event);
    //console.log("28");
    // получение ссылки на хэш-таблицу обработчиков событий
    var handlers = this.events[event.type];
    //console.log("29");
    // выполнение каждого обработчика события
    for(var i in handlers)
    {
        //console.log("30");
        this.$$handleEvent = handlers[i];
        if(this.$$handleEvent(event) === false)
        {
            //console.log("31");
            returnValue = false;
        }
    }
    //console.log('32');
    return returnValue;
};

// Добавление к объекту события IE некоторых "упущенных" методов
function fixEvent(event)
{
    //console.log('33');
    // добавление стандартных методов событий W3C
    event.preventDefault = fixEvent.preventDefault;
    event.stopPropagation = fixEvent.stopPropagation;
    return event;
};

fixEvent.preventDefault = function()
{
    //console.log('34');
    this.returnValue = false;
};

fixEvent.stopPropagation = function()
{
    alert('35');
    this.cancelBubble = true;
};
///////////////////////////////////////////////////////////////////////
//                                                                   //
///////////////////////////////////////////////////////////////////////










HTMLElement.prototype.prevS = function()
{
    var elem = this;
    do
    {
        elem = elem.previousSibling;
    }
    while(elem && elem.nodeType != 1);
    return elem;
}

HTMLElement.prototype.nextS = function()
{
    var elem = this;
    do
    {
        elem = elem.nextSibling;
    }
    while(elem && elem.nodeType != 1);
    return elem;
}

HTMLElement.prototype.firstC = function()
{
    var elem = this;
    elem = elem.firstChild;
    return elem && elem.nodeType != 1 ? nextS(elem) : elem;
}

HTMLElement.prototype.lastC = function()
{
    var elem = this;
    elem = elem.lastChild;
    return elem && elem.nodeType != 1 ? prevS(elem) : elem;
}

HTMLElement.prototype.parentN = function(elem, num)
{
    num = num || 1;
    for(var i = 0; i < num; i++)
    {
        if(elem != null)
        {
            elem = elem.parentNode;
        }
    }
    return elem;
}