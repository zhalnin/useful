/**
 * Created by JetBrains PhpStorm.
 * User: zhalnin
 * Date: 08.04.12
 * Time: 14:44
 * To change this template use File | Settings | File Templates.
 */



/*
Осуществляет задачи, связанные с использованием AJAX
ajax( options )
httpSuccess( r )
httpData ( r, type )

Сериализация структур данных в совместимую с HTTP схему параметров AJAX
serialize( a )

Определение высоты и ширины области просмотра браузера
windowHeight()
windowWidth()

Корректировка позиции области просмотра браузера
scrollTo( 0, 0 )

Определение, где находится область просмотра относительно верхенй части документа
scrollX()
scrollY()

Определение длины и ширины текущей веб-страницы
pageHeight()
pageWidth()

Получение позиции указателя мыши относительно текущего элемента
getElementX( e )
getElementY( e )

Получение ткущей позиции указателя мыши относительно всего пространства страницы
getX( e )
getY( e )

Медленное проявление скрытого элемента за счет увеличения в течение секунды его прозрачности
fadeIn( elem, to, speed )
fadeOut( elem , to, speed )

Медленное появление скрытого элемента за счет увеличения его высоты в течение секунды
slideDown( elem )

Переключение видимости элемента с использованием его CSS-свойства display
hide( elem )
show( elem )

Получение полной потенциональной высоты или ширины элемента, даже если он скрыт
fullHeight( elem )
fullWidth( elem )

Извлечение текущей высоты или ширины DOM-элемента
getHeight( elem )
getWidth( elem )

Установка позиции элемента относительно его текущей позиции
addX( elem, pos )
addY( elem, pos )

Установка X и Y позиций элемента, независимо от его текущей позиции
setX( elem, pos )
setY( elem, pos )

Определение CSS-позиционирования элемента
posX( elem )
posY( elem )

Определение горизонтальной позиции элемента внутри его родителя
parentX( elem )
parentY( elem )

Определение местоположения элемента (x и y) относительно всего документа
pageX( elem )
pageY( elem )

Получение свойства style (name) определенного элемента (elem)
getStyle( elem, name)

Класс доступности javascript

Предотвращение исходных действий браузера
stopDefault( e )

Остановка всплытия события
stopBubble( e )

Создане нового DOM-элемента
create( elem )

Добавление элемента
append( parent, elem )
before( parent, before, elem )
checkElem( e )

Удаление узла
remove( elem )

Удаление всех дочерних узлов
empty( elem )

Установка и получение значений атрибутов элементов
attr( elem, name, value )

Обработка DOM элементов
prev( elem )
next( elem )
first( elem )
last( elem )
parent( elem, num )

Упаковка getElementById
id( elem )

Упаковка getElementsByTagName
tag( name, elem )

Поиск всех элементов + классов
hasClass( name, type )

Добавление класса элементу
addClass( name, type )

Удаление класса элемента
removeClass( name, type )

Извлечение текстового содержимого из элемента
text( e )

Определение наличия у элемента атрибута
hasAttributes( elem, name )

Готовность DOM
domReady( f )
isDOMReady()

Библиотека addEvent/removeEven
addEvent( elem, type, handler )
removeEvent( elem, type, handler )
handleEvent( event )
fixEvent( event )

Конвертирует массив nodes.childNodes в обычный массив
convertToArray(nodes)

Для сериализации HTML строки атрибутов элемента в XML
outputAttributes(element)
*/


///////////////////////////////////////////////////////////////////////
//  Для определения позиции окна браузера в окне монитора            //
// screenLeft/screenTop - IE,Safari,Opera,Chrome                     //
// screenX/screenY - Firefox                                         //
///////////////////////////////////////////////////////////////////////
var leftPos = (typeof window.screenLeft == "number") ?
    window.screenLeft : window.screenX;

var topPosition = (typeof  window.screenTop == "number") ?
    window.screenTop : window.screenY;
///////////////////////////////////////////////////////////////////////
//                                                                   //
///////////////////////////////////////////////////////////////////////




///////////////////////////////////////////////////////////////////////
//  Для осуществления AJAX-запросов                                  //
// принимает одни аргумент, представляющий собой объект, содержащий  //
// набор параметров                                                  //
///////////////////////////////////////////////////////////////////////
function ajax( options )
{
    // Загрузка объекта параметров по умолчанию, если пользователь не
    // представил никаких значений
    options =
    {
        // Режим http-запроса
        type: options.mode || "POST",
        // URL на который должен быть послан запрос
        url: options.url || "",
        // Время ожидания ответа на запрос
        timeout: options.timeout || 5000,
        // Функция, вызываемая, когда запрос неудачен, успешен
        // или завершен (успешно или нет)
        onComplete: options.onComplete || function(){},
        onError: options.onError || function(){},
        onSuccess: options.onSuccess || function(){},
        // Тип данных, которые будут возвращены с сервера
        // по умолчанию просто определить, какие данные были
        // возвращены, и действовать соответственно
        data: options.data || ""
    };
    // Создание объекта запроса
    var xml = new XMLHttpRequest();
    // Открытие асинхронного запроса
    xml.open(options.type, options.url, true);
    // Ожидание отклика на запрос в течение 5 секунд
    // перед тем, как от него отказаться

    var timeoutLength = options.timeout;
    // Отслеживание факта успешного завершения запроса
    var requestDone = false;
    // Инициализация функции обратного вызова, которая будет запущена через
    // 5 секунд, отменяя запрос (если он не будет к тому времени выполнен)
    setTimeout(function()
    {
        requestDone = true;
    }, timeoutLength);

    // Отслеживание обновления состояния документа
    xml.onreadystatechange = function()
    {
        // Ожидание, полной загрузки данных
        // и проверки, не истекло ли время запроса
        if(xml.readyState == 4 && !requestDone)
        {
            // Проверка успешности запроса
            if(httpSuccess(xml))
            {
                // Выполнение в случае успеха функции обратного вызова
                // с данными, возвращенными с сервера
                options.onSuccess(httpData(xml, options.data));
            }
            else
            {
                // В противном случае призошла ошибка, поэтому нужно
                // выполнить функцию обратного вызова для обработки ошибки
                options.onError();
            }
            // Выполнение функции обратного вызова, связанной с завершением
            // запроса
            options.onComplete();
            // Подчистка соединения с сервером
            xml = null;
        }
    };

    // Установка соединения с сервером
    xml.send();

    // Определение успешности получения ответа HTTP
    function httpSuccess(r)
    {
        try
        {
            // Если состояние сервера предоставлено не было, и мы
            // фактически сделали запрос к локальному файлу,
            // значит, он прошел успешно
            return !r.status && location.protocol == "file:" ||
                // нас устраивает любой код состояния в диапазоне 200
                (r.status >=200 && r.status < 300) ||
                // запрос прошел успешно, если документ не подвергся
                // изменениям
                r.status == 304 ||
                // если файл не подвергался изменениям, Safari возвращает
                // пустое состояние
                navigator.userAgent.indexOf("Safari") >= 0
                    && typeof r.status == "undefined";
        }
        catch(e){}
        // Если проверка состояния не удалась, следует предположить,
        // что запрос тоже закончился неудачей
        return false;
    }

    // Извлечение правильных данных из ответа HTTP
    function httpData(r, type)
    {
        // Получение заголовка content-type
        var ct = r.getResponseHeader("content-type");
        // Если не предоставлен тип по умолчанию, определение
        // не возвращена ли с сервера какая-либо форма XML
        var data = !type && ct && ct.indexOf("xml") >= 0;
        // Получение объекта XML-документа, если сервер вернул XML,
        // если нет - возвращение полученного с сервера текстового
        // содержимого
        data = type == "xml" || data ? r.responseXML : r.responseText;
        // Если указан тип "script", выполнение возвращенного текста,
        // реагируя на него, как на JavaScript
        if(type == "script")
            eval.call(window, data);
        // Возвращение данных, полученных в ответе
        return data;
    }
}
///////////////////////////////////////////////////////////////////////
//                                                                   //
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
// Сериализация набора данных AJAX                                   //
///////////////////////////////////////////////////////////////////////
// Может воспринимать два различных пипа объектов:
// - массив элементов ввода
// - хэш, составленный из пар ключ-значение
// Функция возвращает последовательную строку данных
function serialize(a)
{
    // Набор результатов сериализации
    var s = [];
    // Если передан массив, предположение, что он является массивом
    // элементов формы
    if(a.constructor == Array)
    {
        // Сериализация элементов формы
        for(var i = 0; i < a.length; i++)
            s.push(a[i].name + "=" + encodeURIComponent(a[i].value));
    // Если нет, предположение, что это объект, состоящий
    // из пар ключ-значение
    }
    else
    {
        // Сериализация пар ключ-значение
        for(var j in a)
            s.push(j+ "=" + encodeURIComponent(a[j]));
    }
    // возврат результатов сериализации
    return s.join("&");
}
///////////////////////////////////////////////////////////////////////
//                                                                   //
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
// Определение высоты и ширины области просмотра браузера            //
///////////////////////////////////////////////////////////////////////
// Определение высоты области просмотра
function windowHeight()
{
    // Сокращение на случай использования IE6 в строгом
    // (strict) режиме
    var de = document.documentElement;

    // Использование свойства браузера innerHeight, если оно доступно
    return self.innerHeight ||
        // в противном случае попытка получить высоту из корневого узла
        ( de && de.clientHeight ) ||
        // И наконец, попытка получить высоту из элемента body
        document.body.clientHeight;
}
// Определение ширины области просмотра
function windowWidth()
{
    // Сокращение на случай испльзования IE6 в строгом
    // (strict) режиме
    var de = document.documentElement;

    // Использование свойства браузера innerWidth, если оно доступно
    return self.innerWidth ||
        // в противном случае попытка получить ширину из корневого узла
        (de && de.clientWidth) ||
        // И наконец, попытка получить высоту из элемента body
        document.body.clientWidth;
}
///////////////////////////////////////////////////////////////////////
//                                                                   //
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
// Определение, где находится область просмотра относительно         //
// верхенй части документа                                           //
///////////////////////////////////////////////////////////////////////
// Функция для определения величины горизонтальной прокрутки браузера
function scrollX()
{
    // Сокращение на случай использования IE6 в строгом
    // (strict)режиме
    var de = document.documentElement;

    // Использование свойства браузера pageXOffset, если оно доступно
    return self.pageXOffset ||
        // в противном случае попытка получить прокрутку слева из
        // корневого узла
        (de && de.scrollLeft) ||
        // и наконец, попытка получить прокурутку слева из элемента body
    document.body.scrollLeft;
}
// Определение величины вертикальной прокрутки браузера
function scrollY()
{
    // Сокращение на случай использования IE6 в строгом
    // (strict) режиме
    var de = document.documentElement;

    // Использование свойства браузера pageYOffset, если оно доступно
    return self.pageYOffset ||
        // в противном случае попытка получить прокрутку сверху из
        // корневого узла
        ( de && de.scrollTop ) ||
        // и наконец, попытка получить прокрутку сверху из элемента body
        document.body.scrollTop;
}
///////////////////////////////////////////////////////////////////////
//                                                                   //
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
// Определение длины и ширины текущей веб-страницы                   //
///////////////////////////////////////////////////////////////////////
// Возвращение высоты веб-страницы
// может изменяться при добавлении к странице нового содержимого
function pageHeight()
{
    return document.body.scrollHeight;
}
// Возвращение ширины веб-страницы
function pageWidth()
{
    return  document.body.scrollWidth;
}
///////////////////////////////////////////////////////////////////////
//                                                                   //
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
// Получение позиции указателя мыши относительно текущего элемента   //
///////////////////////////////////////////////////////////////////////
// Получение X-позиции указателя мыши относительно целевого элемента,
// который используется в объекте события 'е'
function  getElementX(e)
{
    // Определение соответствующего смещения элемента
    return ( e && e.layerX )|| window.event.offsetX;
}

// Получение Y-позиции указателя мыши относительно целевого элемента,
// который используется в объекте события 'е'
function getElementY(e)
{
    // Определение соответствующего смещения элемента
    return ( e && e.layerY )|| window.event.offsetY;
}
///////////////////////////////////////////////////////////////////////
//                                                                   //
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
// Получение указателя мыши относительно всего                       //
// пространства страницы                                             //
///////////////////////////////////////////////////////////////////////
// Получение горизонтальной позиции указателя
function getX(e)
{
    // Нормализация объекта события
    e = e || window.event;

    // Сначала получение позиции из браузеров, не относящихся к IE,
    // а затем из IE
    return e.pageX || e.clientX + document.body.scrollLeft;
}

// Получение вертикальной позиции указателя
function getY(e)
{
    // Нормализация объекта
    e = e || window.event;

    // Сначала получение позиции из браузеров, не относящихся к IE,
    // затем из IE
    return e.pageY || e.clientY + document.body.scrollTop;
}
///////////////////////////////////////////////////////////////////////
//                                                                   //
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
// Медленное проявление скрытого элемента за счет увеличения         //
// в течение секунды его непрозрачности                              //
///////////////////////////////////////////////////////////////////////
function fadeIn( elem, to, speed )
{
    // Начало непрозрачности с 0
    setOpacity(elem, 0);
    // Отображение элемента ( но вы его не увидите, пока непрозрачность
    // равна 0)
    show( elem );
    // Мы собираем я за секунду показать анимацию, состоящую из
    // 20 "кадров"
    for( var i = 0; i <= 100; i+=5)
    {
//        alert("i - "+i);
        // Замкнутое выражение, гарантирующее, что у нас в распоряжении
        // находится именно та переменная 'i', которая нам нужна
        (function()
        {
            var opacity = i;
//            alert("pos - "+opacity);
            // Установка времени ожидания для совершения будущих
            //  действий в определенное время
            setTimeout(function()
            {
//                alert("second i - "+i);
//                alert("second pos - "+opacity);
                // Установка новой степени прозрачности элемента
                setOpacity( elem, (opacity / 100) * to );
            }, (i + 1) * speed);
        })();
    }
}
///////////////////////////////////////////////////////////////////////
//                                                                   //
///////////////////////////////////////////////////////////////////////


function fadeOut( elem, to, speed )
{
    // Начало непрозрачности с 1
//    setOpacity(elem, 100);
    // Отображение элемента ( но вы его не увидите, пока непрозрачность
    // равна 0)
//    hide( elem );

    // Мы собираемся за секунду показать анимацию, состоящую из
    // 20 "кадров"
    for( var i = 100; i >= 0; i-=5)
    {
//        console.log(i);
        // Замкнутое выражение, гарантирующее, что у нас в распоряжении
        // находится именно та переменная 'i', которая нам нужна
        (function()
        {
            var opacity = i;
//            console.log("first pos - "+opacity);
//            console.log(pos);
            // Установка времени ожидания для совершения будущих
            //  действий в определенное время
            setTimeout(function()
            {
                // Установка новой степени прозрачности элемента
//                console.log("p - "+opacity);
                
                setOpacity( elem, 100 - opacity );
                if(opacity == 95)
                    hide( elem );
            }, (i + 1) * speed);
        })();
    }
}











///////////////////////////////////////////////////////////////////////
//  Медленное появление скрытого элемента за счет увеличения         //
//  его высоты в течение секунды                                     //
///////////////////////////////////////////////////////////////////////
function slideDown( elem, speed )
{
    // Начало выплывания вниз с 0
//    elem.style.height = 0+'px';

    // Показ элемента ( но вы его не увидите, пока высота равна 0)
    show( elem );

    if( ! speed ) {
        speed = 0;
    }

    // Определение полной, потенциальной высоты элемента
    var h = fullHeight( elem );

    // Мы собираемся за секунду показать анимацию, состоящую из
    // 20 кадров
    for( var i = 0; i <= 100; i += 5)
    {
        // Замкнутое выражение, гарантирующее, что у нас в паспоряжении
        // находится именно та переменная 'i', которая нам нужна
        (function()
        {
            var pos = i;

            // Установка времени ожидания для совершения будущих
            // действий в определенное время
            setTimeout(function()
            {                // Установка новой высоты элемента
                elem.style.height = ( pos / 100 ) * h + "px";

            }, ( pos + 1 ) * speed);
        })();
    }
}
///////////////////////////////////////////////////////////////////////
//                                                                   //
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//  Корректировка уровня прозрачности элемента                       //
///////////////////////////////////////////////////////////////////////
// Установка уровня прозрачности элемента
// где уровень является числом в диапазоне 0 - 100
function setOpacity( elem, level )
{
    // Если существуют какие-нибудь фильтры, значит,
    // мы имеем дело с IE, и нужно устанавливать фильта Alpha
    if( elem.filters )
    {
//        alert(elem);
//        elem.filters.alpha.opacity = level;
        elem.style.filters = 'alpha(opacity='+ level + ')';

    }



    // В противном случае мы используем W3C-свойство opacity
    else
        elem.style.opacity = level / 100;
}
///////////////////////////////////////////////////////////////////////
//                                                                   //
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//  Переключение видимости элемента с использованием его CSS-свойства//
// display                                                           //
///////////////////////////////////////////////////////////////////////
// Функция для скрытия элемента (с использованием свойства display)
function hide( elem )
{
    // Определение текущего состояния свойства display
    var curDisplay = getStyle( elem, 'display');

    // Запоминание состояния свойства display на будущее
    if( curDisplay != 'none' )
        elem.$oldDisplay = curDisplay;

    // Установка display в none (сокрытие элемента)
    elem.style.display = 'none';
}
// Функция показа элемента (с использование свойства display)
function show( elem )
{
    // Возвращение свойства display к тому значеню, которое им
    // использовалось, или использование
    // 'block', если предыдущее состояние этого свойства не было
    // сохранено
    elem.style.display = elem.$oldDisplay || 'block';
}
///////////////////////////////////////////////////////////////////////
//                                                                   //
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
// Получение полной потенциональной высоты или ширины элемента,      //
// даже если он скрыт                                                //
///////////////////////////////////////////////////////////////////////
// Получение полной возможной высоты элемента ( в отличие от фактической
// текущей высоты )
function fullHeight( elem )
{
    // Если элемент отображен на экране, то сработает свойство
    // offsetHeight, а если оно не сработает, то сработает getHeight()
    if( getStyle( elem, 'display') != 'none')
        return elem.offsetHeight || getHeight( elem );

    // В противном случае нам придется иметь дело с элементом,
    // у которого display имеет значение none, поэтому
    // нужно переустановить его CSS-свойства, чтобы считать более
    // точный результат
    var old = resetCSS( elem,
        {
           display: '',
            visibility: 'hidden',
            position: 'absolute'
        });

    // Определяем полную высоту элемента, используя clientHeight,
    // а если это свойство не работает, используем getHeight
    var h = elem.clientHeight || getHeight( elem );

    // В завершение восстанавливаем прежние CSS-свойства
    restoreCSS( elem, old );

    // и возвращаем полную высоту элемента
    return h;
}

// Получение полной возможной ширины элемента ( в отличие от фактической
// текущей ширины )
function fullWidth( elem )
{
    // Если элемент отображен на экране, то сработает свойство
    // offsetWidth а если оно не сработает, то сработает getWidth()
    if( getStyle( elem, 'display') != 'none' )
        return elem.offsetWidth || getWidth( elem );
    // В противном случае нам предется иметь дело с элементом,
    // у которого display имеет значение none, поэтому
    // нужно переустановить его CSS-свойства, чтобы считать более
    // точный результат
    var old = resetCSS( elem,
        {
           display: '',
            visibility: 'hidden',
            position: 'absolute'
        });
    // Определяем полную ширину элемента, используя clientWidth,
    // а если это свойство не работает, используем getWidth
    var w = elem.clientWidth || getWidth( elem );
    // В завершение восстанавливаем прежние CSS-свойства
    restoreCSS( elem, old );
    // и возвращаем полную ширину элемента
    return w;
}

// Функция, используемая для переустановки наора CSS-свойств, которые
// позже можно будет восстановить
function resetCSS( elem, prop )
{
    var old = {};
    // Перебор всех свойств
    for( var i in prop )
    {
        // Запоминание старых значений свойств
        old[ i ] = elem.style[ i ];
        // и установка новых значений
        elem.style[ i ] = prop[i];
    }
    // возвращение набора значений для использования в функции restoreCSS
    return old;
}

// Функция для устранения побочных эффектов функции resetCSS
function restoreCSS( elem, prop )
{
    // Переустановка всех свойств и возвращение им первоначальных значений
    for( var i in prop )
        elem.style[ i ] = prop[i];
}
///////////////////////////////////////////////////////////////////////
//                                                                   //
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
// Извлечение текущей высоты или ширины DOM-элемента                 //
///////////////////////////////////////////////////////////////////////
// Получение текущей высоты элемента(с использованием вычисляемого CSS
function getHeight( elem )
{
    // Получение вычисялемого значения CSS и извлечения необходимого
    // числового значения
    return parseInt( getStyle( elem, 'height' ));
}
// Получение текущей ширины элемента ( с использованием вычисляемого CSS)
function getWidth( elem )
{
    // Получение вычисляемого значения CSS и извлечение необходимого
    // числового значения
    return parseInt( getStyle( elem, 'width' ));
}
///////////////////////////////////////////////////////////////////////
//                                                                   //
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//  Установка позиции элемента относительно его текущей позиции      //
///////////////////////////////////////////////////////////////////////
// Функция добавления пикселов к горизонтальной позиции элемента
function addX( elem, pos )
{
    // Получение текущей горизонтальной позиции и добавление к ней
    // смещения
    setX( elem, posX( elem ) + pos);
}
// Функция добавления писелов к вертикальной позиции элемента
function addY( elem, pos )
{
    // Получение текущей вертикальной позиции и добавление к ней
    // мещения
    setY( elem, posY( elem ) + pos);
}
///////////////////////////////////////////////////////////////////////
//                                                                   //
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//  Установка X и Y позиций элемента, независимо от текущей позиции  //
///////////////////////////////////////////////////////////////////////
// Установка горизонтальной позиции элемента
function setX( elem, pos )
{
    // Установка CSS-свойства 'left' с использование единицы измерения,
    // выраженной в пикселах
    elem.style.left = pos + "px";
}
// Установка вертикальной позиции элемента
function setY( elem, pos )
{
    // Установка CSS-свойства 'top' с использованием единицы измерения,
    // выраженной в пикселах
    elem.style.top = pos + "px";
}
///////////////////////////////////////////////////////////////////////
//                                                                   //
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
// Определение CSS-позиционирования элемента                         //
///////////////////////////////////////////////////////////////////////
// Определение левой позиции элемента
function posX( elem )
{
    // Получение вычисляемого значения style и извлечение числа из значения
    return parseInt( getStyle( elem, "left" ));
}
// Определение верхней позиции элемента
function posY( elem )
{
    // Получение вычисляемого значения style и извлечение числа из значения
    return parseInt( getStyle( elem, "top" ));
}
///////////////////////////////////////////////////////////////////////
//                                                                   //
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
// Определение горизонтальной позиции элемента внутри его родителя   //
///////////////////////////////////////////////////////////////////////
// Определение горизонтальной позиции элемента внутри его родителя
function parentX( elem )
{
    // Если offsetParent указывает на родителя элемента, то ранее
    // завершение работы
    return elem.parentNode == elem.offsetParent ?
        elem.offsetLeft:
        // В противном случае нужно найти позицию относительно всей страницы
        // для обоих элементов и вычислить разницу
        pageX( elem ) - pageX( elem.parentNode );
}
// Определение вертикальной позиции элемента внутри его родителя
function parentY( elem )
{
    // Если offsetParent указывает на родителя элемента, то ранее
    // завершение работы
    return elem.parentNode == elem.offsetParent ?
        elem.offsetTop :
        // В противном случае нужно найти позицию относительно всей страницы
        // для обоих элементов и вычислить разницу
        pageY( elem ) - pageY( elem.parentNode);
    
}
///////////////////////////////////////////////////////////////////////
//                                                                   //
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
// Определение местоположения элемента (x и y)                       //
///////////////////////////////////////////////////////////////////////
// Определение X (горизонтальной слева) позиции элемента
function pageX( elem )
{
    // Проверка на достижение корневого элемента
    return elem.offsetParent ?
        // Если не дошли до самого верха, добавление текущего смещения и
        // продолжение движения вверх
        elem.offsetLeft + pageX( elem.offsetParent ) :
        // В противном случае, получение текущего смещения
        elem.offsetLeft;
}
// Определение Y (вертикальной сверху) позиции элемента
function pageY( elem )
{
    // Проверка на достижение корневого элемента
    return elem.offsetParent ?
        // Если не дошли до самого верха, добавление текущего смещения и
        // продолжение движения вверх
        elem.offsetTop + pageY( elem.offsetParent ) :
        // В противном случае, получение текущего смещения
        elem.offsetTop;
}
///////////////////////////////////////////////////////////////////////
//                                                                   //
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//   Получение свойства style( name ) определенного элемента ( elem )//
///////////////////////////////////////////////////////////////////////
function getStyle( elem, name)
{
    // Если свойство присутствует в style[], значит, оно было
    // недавно установлено ( и является теущим)
    if(elem.style[name])
    {
        return elem.style[name];
    }
    // В противном случае, попытка воспользоваться методом IE
    else if(elem.currentStyle)
        return elem.currentStyle[name];

    // Или методом W3C, если он существует
    else if(document.defaultView && document.defaultView.getComputedStyle)
    {
        // Вместо textAlign в нем используется традиционное правило
        // написания стиля - 'text-align'
        name = name.replace(/([A-Z])/g,"-$1");
        name = name.toLowerCase();

        // Получение объекта style и получение значения свойства
        // (если оно существует)
        var s = document.defaultView.getComputedStyle(elem,"");
        return s && s.getPropertyValue(name);

        // В противном случае, мы используем какой-то другой браузер
    }
    else
        return null;
}
///////////////////////////////////////////////////////////////////////
//                                                                   //
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//   Класс доступности javascript                                    //
///////////////////////////////////////////////////////////////////////
//<script>document.documentElement.className = "js";</script>
//<style>.js #fadein { display: none };</style>
//<div id='fadein'>....</div>
///////////////////////////////////////////////////////////////////////
//                                                                   //
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//   Предотвращение исходных действий браузера                       //
///////////////////////////////////////////////////////////////////////
function stopDefault(e)
{
    // Предотвращение исходных действий браузера (W3C)
    if(e && e.preventDefault)
    {
        e.preventDefault();
    }
    else
    {
        // Ссылка на остановку действия браузера в IE
        window.event.returnValue = false;
    }
    return false;
}
///////////////////////////////////////////////////////////////////////
//                                                                   //
///////////////////////////////////////////////////////////////////////



///////////////////////////////////////////////////////////////////////
//  Остановка всплытия события                                       //
///////////////////////////////////////////////////////////////////////
function stopBubble(e)
{
    // Если предоставлен объект события, значит это не IE-браузер
    if(e && e.stopPropagation)
    {
        // и он поддерживает W3C-метод stopPropagation()
        e.stopPropagation();
    }
    else
    {
        // В противном случае нужно воспользоваться способом
        // прекращения всплытия события, существующим в IE
        window.event.cancelBubble = true;
    }
}
///////////////////////////////////////////////////////////////////////
//                                                                   //
///////////////////////////////////////////////////////////////////////



///////////////////////////////////////////////////////////////////////
//  Удаление из DOM отдельного узла                                  //
///////////////////////////////////////////////////////////////////////
function remove( elem )
{
    if(elem) elem.parentNode.removeChild(elem);
}
///////////////////////////////////////////////////////////////////////
//                                                                   //
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//  Удаление из DOM всех дочерних узлов элемента                     //
///////////////////////////////////////////////////////////////////////
function empty(elem)
{
    //console.log(elem.firstChild);
    while(elem.firstChild)
    {
        remove(elem.firstChild);
    }
}
///////////////////////////////////////////////////////////////////////
//                                                                   //
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//  Создание нового DOM-элемента                                     //
///////////////////////////////////////////////////////////////////////
function create( elem )
{
    return document.createElementNS ?
        document.createElementNS('http://www.w3.org/1999/xhtml', elem) :
        document.createElement( elem );
}
///////////////////////////////////////////////////////////////////////
//                                                                   //
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//  Вставка элемента перед другим элементом                          //
///////////////////////////////////////////////////////////////////////
function before(parent, before, elem)
{
    // Выяснение, предоставлен ли родительский (parent) узел
    if(elem == null)
    {
        elem = before;
        before = parent;
        parent = before.parentNode;
    }

    // Получение нового массива элементов
    var elems = checkElem(elem);
//    console.log(elems);
    // Обратный перебор элементов массива,
    // поскольку мы добавляем элементы к началу
    for(var i = elems.length - 1; i >= 0; i-- )
    {
//        console.log(parent);
        parent.insertBefore(elems[i], before);
    }
}
///////////////////////////////////////////////////////////////////////
//                                                                   //
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//  Добавление элемента в качестве дочернего к другому элементу      //
///////////////////////////////////////////////////////////////////////
function append(parent, elem)
{
    // Получение массива элементов
    var elems = checkElem(elem);

    // Добавление всех элементов к родительскому элементу
    for(var i = 0; i <= elems.length-1; i++)
    {
        parent.appendChild(elems[i]);
    }

}
///////////////////////////////////////////////////////////////////////
//                                                                   //
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//  Вспомогательная для before и append                              //
///////////////////////////////////////////////////////////////////////
function checkElem( a )
{
    //console.log(a);
    var r = [];
    // Превращение аргумента в массив, если он еще им не является
    if( a.constructor != Array ) a = [a];
    //console.log(a);
    for(var i = 0; i < a.length; i++)
    {
        //console.log(a);
        // Если это строка
        if(a[i].constructor == String)
        {
            //console.log("string");
            // Создание временного элемента для помещения в него HTML
            var div = document.createElement("div");

            // Вставка HTML, для превращения его в DOM-структуру
            div.innerHTML = a[i];

            // Обратное извлечение DOM-структуры из временного DIV-элемента
            for(var j = 0; j < div.childNodes.length; j++)
            {
                //console.log(div.childNodes.length);
                r[r.length] = div.childNodes[j];
            }
        }
        else if(a[i].length)
        {
            //console.log("not string");
            // Если это массив DOM-узлов
            for(var j = 0; j < a[i].length; j++)
            {
                r[r.length] = a[i][j];
            }
        }
        else
        {
            //console.log("DOM-node");
            // Иначе, предположение, что это DOM-узел
            r[r.length] = a[i];
            //console.log(r);
        }
    }
    return r;
}
///////////////////////////////////////////////////////////////////////
//                                                                   //
///////////////////////////////////////////////////////////////////////



///////////////////////////////////////////////////////////////////////
//  Установка и получение значений атрибутов элементов               //
///////////////////////////////////////////////////////////////////////
function attr(elem, name, value)
{
    // Гарантирование допустимости предоставленного имени
    if(!name || name.constructor != String) return '';

    // Определение, не относится ли это имя к тем самым "роковым"
    // именам
    name = { 'for':'htmlFor', 'class':'className', 'float':'cssFloat', 'text':'cssText'}[name] || name;

    // Если пользователь устанавливает значение, то также
    if(typeof value != 'undefined')
    {
        // сначала установить быстрый способ
        elem[name] = value;

        // По возмоности воспользоваться setAttribute
        if(elem.setAttribute)
            elem.setAttribute(name, value);
    }

    // Вернуть значение атрибута
    return elem[name] || elem.getAttribute(name) || '';
}
///////////////////////////////////////////////////////////////////////
//                                                                   //
///////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////
//  Функции обработки DOM элементов                             //
//////////////////////////////////////////////////////////////////
// Ищем предыдущий сестринский элемент
function prev(elem)
{
    do
    {
        elem = elem.previousSibling;
    }
    while(elem && elem.nodeType != 1);
    return elem;
}


// Ищем следующий сестринский эелемент
function next(elem)
{
    do
    {
        elem = elem.nextSibling;
    }
    while(elem && elem.nodeType != 1);
    return elem;
}


// Ищем первый дочерний элемент
function first(elem)
{
    elem = elem.firstChild;
    return elem && elem.nodeType != 1 ? next(elem) : elem;
}


// Ищем последний дочерний элемент
function last(elem)
{
    elem = elem.lastChild;
    return elem && elem.nodeType != 1 ? prev(elem) : elem;
}


// Ищем родительский элемент
function parent(elem, num)
{
    num = num || 1;
    for(var i = 0; i < num; i++)
    {
        if(elem != null)
        {
            elem = elem.parentNode;
        }
    }
    return elem;
}
///////////////////////////////////////////////////////////////////////
//                                                                   //
///////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////
//  Функции упаковки getElementById и getElementsByTagName          //
//////////////////////////////////////////////////////////////////////
// Функция для упаковки getElementById
function id(name)
{
    return document.getElementById(name);
}

// Функция обнаружения элементов по имени тега внутри HTML DOM-документа
function tag(name, root)
{
    // Если конкретный элемент не предоставлен, вести поиск по всему
    // документу
    return (root || document).getElementsByTagName(name);
}
///////////////////////////////////////////////////////////////////////
//                                                                   //
///////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////
//  Функции поиска всех элементов hasClass                          //
//////////////////////////////////////////////////////////////////////
function hasClass(name,type)
{
    var r = [];
    // Обнаружение имени класса (работает и при наличии
    // нескольких имен классов
    var re = new RegExp("(^|\\s)"+name+"(\\s|$)");
    // Ограничение поиска элементами определенного типа
    // или поиск по всем элементам
    var e = document.getElementsByTagName(type || "*");
    for(var j = 0; j < e.length; j++)
    {
        // Если элемент имеет нужный класс, добавление его в
        // возвращаемый массив
//        if((e[j]).className.match(re))
//        {
//            r.push(e[j]);
//        }
        if(re.test(e[j].className))
        {
            r.push(e[j]);
        }
    }
    return r;
}
///////////////////////////////////////////////////////////////////////
//                                                                   //
///////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////
// Функция добавления класса элементу                                //
///////////////////////////////////////////////////////////////////////
function addClass(name,type)
{
    if (this.hasClass(name, type) == ''){
        // Ограничение поиска элементами определенного типа
        // или поиск по всем элементам
        var e = typeof type == 'object' ? type : document.getElementsByTagName(type || "*");
        if(e.constructor == HTMLCollection)
        {
            for(var j = 0; j < e.length; j++)
            {
                e[j].className = name;
            }
        }
        else
        {
            e.className = name;
        }
    }
}
///////////////////////////////////////////////////////////////////////
//                                                                   //
///////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////
//  Функция удаления класса из элемента                              //
///////////////////////////////////////////////////////////////////////
function removeClass(name,type) {
    // Ограничение поиска элементами определенного типа
    // или поиск по всем элементам
    var e = typeof type == 'object' ? type : document.getElementsByTagName(type || "*");
    // Обнаружение имени класса (работает и при наличии
    // нескольких имен классов
    var re = new RegExp("(^|\\s)"+name+"(\\s|$)");
    if(e.constructor == HTMLCollection) {
        for(var j = 0; j < e.length; j++) {
            if(hasClass(name, e[j])){
                e[j].className = e[j].className.replace(re,'');
            }
        }
    } else {
        e.className = e.className.replace(re,' ');
    }
}
///////////////////////////////////////////////////////////////////////
//                                                                   //
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//  Функция для извлечения текстового содержимого элементов          //
///////////////////////////////////////////////////////////////////////
function text(e)
{
    var t = "";

    // Если элемент был передан, получение его дочерних элементов
    // иначе, предположение о том, что передан массив
    e = e.childNodes || e;
    // Просмотр всех дочерних узлов
    for(var j = 0; j < e.length; j++)
    {
        // Если это не элемент, присоединить его текстовое значение
        // иначе, провести рекурсивный перебор всех дочерних составляющих
        // элемента
        t += e[j].nodeType != 1 ? e[j].nodeValue : text(e[j].childNodes);

    }
    return t;
}
///////////////////////////////////////////////////////////////////////
//                                                                   //
///////////////////////////////////////////////////////////////////////


/**
 * Определение наличия у элемента атрибута
 * @param elem
 * @param name
 */
function hasAttributes(elem, name)
{
    return elem.getAttribute(name) != null;
}
///////////////////////////////////////////////////////////////////////
//                                                                   //
///////////////////////////////////////////////////////////////////////


/**
 * Готовность DOM
 *
 * @param f
 */
// Функция, предназначенная для отслеживания готовности DOM
function domReady(f)
{
    //console.log("1");
    // Если DOM уже загружен, немедленно выполнить функцию
    if(domReady.done)
    {
        //console.log("2");
        return f();
    }

    // Если мы уже дополнили функцию
    if(domReady.timer)
    {
        //console.log("3");
        // внести ее в список исполняемых
        domReady.ready.push(f);
        //console.log("4");
    }
    else
    {
        //console.log("5");
        // Привязывание события завершения загрузки страницы,
        // на тот случай если ее загрузка закончится первой.
        // Здесь используется addEvent.
        addEvent(window, "load", isDOMReady);
        //console.log("6");
        // Инициализация массива иполняемых функций
        domReady.ready = [ f ];
        //console.log("7");
        // Проверка DOM на готовность, проводимая как можно быстрее
        domReady.timer = setInterval(isDOMReady, 13);
        //console.log("8");
    }
}

// Проверка на готовность DOM к перемещению по ее структуре
function isDOMReady()
{
    //console.log("9");
    // Если мы уже определили готовность страницы - проигнорировать
    // дальнейшее выполнение
    if(domReady.done)
    {
        //console.log("10");
        return false;
    }

    // Проверка доступности некоторых функций и элеметов
    if(document && document.getElementsByTagName &&
        document.getElementById && document.body)
    {
        //console.log("11");
        // Если они готовы, можно прекратить проверку
        clearInterval(domReady.timer);
        domReady.timer = null;
        //console.log("12");

        // Выполнение всех ожидавших функций
        for(var i = 0; i < domReady.ready.length; i++)
        {
            //console.log('13');
            domReady.ready[i]();
        }

        //console.log("14");
        // Сохранение того, что только что было сделано
        domReady.ready = null;
        domReady.done = true;
        //console.log("15");
    }
}
///////////////////////////////////////////////////////////////////////
//                                                                   //
///////////////////////////////////////////////////////////////////////

/**
 * Событие event кроссбраузерное
 * @param event
 * @returns event
 */
function getEvent(event){
    return event ? event : window.event;
}

/**
 * Кроссбраузерное определение target событияa
 * @param event
 * @returns target
 */
function getTarget(event){
    return event.target ? event.target : event.srcElement;
}

/**
 * Page coordinates
 * @param element
 * @param type
 * @param handler
 */
//addEvent(element,'click',function(event){
//    event = getEvent(event);
//    var pageX = event.pageX,
//        pageY = event.pageY;
//
//    if(pageX === undefined){
//        pageX = event.clientX + (document.body.scrollLeft ||
//            document.documentElement.scrollLeft);
//    }
//
//    if(pageY === undefined){
//        pageY = event.clientY + (document.body.scrollTop ||
//            document.documentElement.scrollTop);
//    }
//    alert("Page coordinates: " + pageX + "," + pageY);
//});


/**
 * Библиотека addEvent/removeEvent
 *
 * @param element
 * @param type
 * @param handler
 */
// addEvent/removeEvent written by Dean Edwards, 2005
// with input from Tino Zijdel
// http://dian.edwards.name/weblog/2005/10/add-event/

function addEvent(element, type, handler)
{
    //console.log(element, type, handler);
    //console.log("16");
    // присвоение каждому обработчику события уникального ID
    if(!handler.$$guid)
    {
        //console.log('17');
        handler.$$guid = addEvent.guid++;
    }
    //console.log("18");
    // создание хэш-таблицы видов событий для элемента
    if(!element.events)
    {
        element.events = {};
        //console.log('19');
    }

    // создание хэш-таблицы обработчиков событий для каждой пары
    // элемент-событие
    var handlers = element.events[type];
    //console.log("20");
    if(!handlers)
    {
        handlers = element.events[type] = {};
        //console.log('21');
        // сохранение существующего обработчика события
        // (если он существует)
        if(element["on" + type])
        {
            handlers[0] = element["on" + type];
            //console.log("22");
        }
    }

    // сохранение обработчика события в хэш-таблице
    handlers[handler.$$guid] = handler;
    //console.log("23");
    // назначение глобального обработчика события для выполнения
    // всей работы
    element["on" + type] = handleEvent;
    //console.log("24");
};

// счетчик, используемый для создания уникальных ID
addEvent.guid = 1;

function removeEvent(element, type, handler)
{
    //console.log("25");
    // удаление обработчика события из хэш-таблицы
    if(element.events && element.events[type])
    {
        //console.log('26');
        delete element.events[type][handler.$$guid];
    }
};

function handleEvent(event)
{
    //console.log('27');
    var returnValue = true;

    // захват объекта события (IE использует глобальный объект события)
    event = event || fixEvent(window.event);
    //console.log("28");
    // получение ссылки на хэш-таблицу обработчиков событий
    var handlers = this.events[event.type];
    //console.log("29");
    // выполнение каждого обработчика события
    for(var i in handlers)
    {
        //console.log("30");
        this.$$handleEvent = handlers[i];
        if(this.$$handleEvent(event) === false)
        {
            //console.log("31");
            returnValue = false;
        }
    }
    //console.log('32');
    return returnValue;
};

/**
 * Добавление к объекту события IE некоторых "упущенных" методов
 * @param event
 */
function fixEvent(event)
{
    //console.log('33');
    // добавление стандартных методов событий W3C
    event.preventDefault = fixEvent.preventDefault;
    event.stopPropagation = fixEvent.stopPropagation;
    return event;
};

fixEvent.preventDefault = function()
{
    //console.log('34');
    this.returnValue = false;
};

fixEvent.stopPropagation = function()
{
    alert('35');
    this.cancelBubble = true;
};
///////////////////////////////////////////////////////////////////////
//                                                                   //
///////////////////////////////////////////////////////////////////////









//
//HTMLElement.prototype.prevS = function()
//{
//    var elem = this;
//    do
//    {
//        elem = elem.previousSibling;
//    }
//    while(elem && elem.nodeType != 1);
//    return elem;
//}
//
//HTMLElement.prototype.nextS = function()
//{
//    var elem = this;
//    do
//    {
//        elem = elem.nextSibling;
//    }
//    while(elem && elem.nodeType != 1);
//    return elem;
//}
//
//HTMLElement.prototype.firstC = function()
//{
//    var elem = this;
//    elem = elem.firstChild;
//    return elem && elem.nodeType != 1 ? nextS(elem) : elem;
//}
//
//HTMLElement.prototype.lastC = function()
//{
//    var elem = this;
//    elem = elem.lastChild;
//    return elem && elem.nodeType != 1 ? prevS(elem) : elem;
//}
//
//HTMLElement.prototype.parentN = function(elem, num)
//{
//    num = num || 1;
//    for(var i = 0; i < num; i++)
//    {
//        if(elem != null)
//        {
//            elem = elem.parentNode;
//        }
//    }
//    return elem;
//}


/**
 * Обработчик для mouseover
 * @param event
 */
function mouseoverHandler(event) {
	event = event || window.event
	var relatedTarget = event.relatedTarget || event.fromElement
	// для mouseover
	// relatedTarget - элемент, с которого пришел курсор мыши
}

/**
 *  Обработчик для mouseout
 * @param event
 */
function mouseoutHandler(event) {
	event = event || window.event
	var relTarg = event.relatedTarget || event.toElement
	// для mouseout
	// relatedTarget - элемент, на который перешел курсор мыши
}
//для IE, взяв то свойство из fromElement/srcElement, которое не равно target:

//if (!e.relatedTarget && e.fromElement) {
//  e.relatedTarget = (e.fromElement==e.target) ? e.toElement : e.fromElement
//}


//test for the existence of a function on any object in a browser environment
//credit: Peter Michaux
function isHostMethod(object, property) {
  var t = typeof object[property]; return t=="function" ||
  (!!(t=="object" && object[property])) || t=="unknown";
}




/**
 * Dynamic load script javascript
 * @param url
 */
function loadScript(url){
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src = url;
    document.head.appendChild(script);
}



/**
 * Dynamic Scripts
 * @param code
 */
function loadScriptString(code)
{
    var script = document.createElement("script");
    script.type = "text/javascript";
    try
    {
        script.appendChild(document.createTextNode(code));
    }
    catch(ex)
    {
        script.text = code;
    }
    document.body.appendChild(script);
}
//loadScriptString("function sayHi() { alert('hi');}");

/**
 * Dynamic Styles
 * @param url
 */
function loadStyles(url)
{
    var link = document.createElement("link");
    link.rel = "stylesheet";
    link.type = "text/css";
    link.href = url;
    var head = document.getElementsByTagName("head")[0];
    head.appendChild(link);
}

function loadStyleString(css)
{
    var style = document.createElement("style");
    style.type = "text/css";
    try
    {
        style.appendChild(document.createTextNode(css));
    }
    catch(ex)
    {
        style.stylesheet.cssText = css;
    }
    var head = document.getElementsByTagName("head")[0];
    head.appendChild(style);
}
//loadStyleString("body{background-color: red}");

/**
 * MatchesSelector.
 * @param element
 * @param selector
 */
function matchesSelector(element, selector)
{
    if(element.matchesSelector)
    {
        return element.matchesSelector(selector);
    }
    else if (element.msMatchesSelector)
    {
        return element.msMatchesSelector(selector);
    }
    else if (element.mozMatchesSelector)
    {
        return element.mozMatchesSelector(selector);
    }
    else if (element.webkitMatchesSelector)
    {
        return element.webkitMatchesSelector(selector);
    }
    else
    {
        throw new Error("Not supported.");
    }
}

/**
 * Contains
 * @param refNode
 * @param otherNode
 */
function contains(refNode, otherNode)
{
    if(typeof refNode.contains == "function" &&
            (!client.engine.webkit || client.engine.webkit >= 522))
    {
        return refNode.contains(otherNode);
    }
    else if(typeof refNode.compareDocumentPosition == "function")
    {
        return !!(refNode.compareDocumentPosition(otherNode) & 16);
    }
    else
    {
        var node = otherNode.parentNode;
        do
        {
            if(node === refNode)
            {
                return true;
            }
            else
            {
                node = node.parentNode;
            }
        }
        while(node !== null);
        return false;
    }
}


/**
 * Rendering engines
 */
var client = function() {

    var engine = {
        ie: 0,
        gecko: 0,
        webkit: 0,
        khtml: 0,
        opera: 0,

        // complete version
        ver: null
    };

    // browsers
    var browser = {
        ie: 0,
        firefox: 0,
        safari: 0,
        konq: 0,
        opera: 0,
        chrome: 0,

        // specific version
        ver: null
    };

    // platform/device/OS
    var system = {
        win: false,
        mac: false,
        x11: false,

        // mobile devices
        iphone: false,
        ipod: false,
        ipad: false,
        ios: false,
        android: false,
        nokiaN: false,
        winMobile: false,

        // game systems
        wii: false,
        ps: false
    };

    // detect rendering engines/browsers
    var ua = navigator.userAgent;

    if(window.opera) {
        engine.ver = browser.ver = window.opera.version();
        engine.opera = browser.opera = parseFloat(engine.ver);
    } else if (/AppleWebKit\/(\S+)/.test(ua)) {
        engine.ver = RegExp["$1"];
        engine.webkit = parseFloat(engine.ver);

        // figure out if it's Chrome or Safari
        if (/Chrome\/(\S+)/.test(ua)) {
            browser.ver = RegExp["$1"];
            browser.chrome = parseFloat(browser.ver);
        } else if (/Version\/(\S+)/.test(ua)) {
            browser.ver = RegExp["$1"];
            browser.safari = parseFloat(browser.ver);
        } else {
            // approximate version
            var safariVersion = 1;
            if(engine.webkit < 100) {
                safariVersion = 1;
            } else if (engine.webkit < 312) {
                safariVersion = 1.2;
            } else if (engine.webkit < 412) {
                safariVersion = 1.3;
            } else {
                safariVersion = 2;
            }
            browser.safari = browser.ver = safariVersion;
        }
    } else if (/KHTML\/(\S+)/.test(ua)) {
        engine.ver = browser.ver = RegExp["$1"];
        engine.khtml = browser.khtml = parseFloat(engine.ver);
    } else if (/rv:([^\)]+)\) Gecko\/\d{8}/.test(ua)) {
        engine.ver = RegExp["$1"];
        engine.gecko = parseFloat(engine.ver);

        // determine if it's Firefox
        if (/Firefox\/(\S+)/.test(ua)) {
            browser.ver = RegExp["$1"];
            browser.firefox = parseFloat(browser.ver);
        }
    } else if (/MSIE ([^;]+)/.test(ua)) {
        engine.ver = browser.ver = RegExp["$1"];
        engine.ie = browser.ie = parseFloat(engine.ver);
    }

    // detect browsers
    browser.ie = engine.ie;
    browser.opera = engine.opera;

    // detect platform
    var p = navigator.platform;
    system.win = p.indexOf("Win") == 0;
    system.mac = p.indexOf("Mac") == 0;
    system.x11 = (p.indexOf("X11") == 0) || (p.indexOf("Linux") == 0);

    // detect windows operating system
    if (system.win) {
        if(/Win(?:dows)?([^do]{2})\s?(\d+\.\d+)?/.test(ua)) {
            if (RegExp["$1"] == "NT") {
                switch(RegExp["$2"]) {
                    case "5.0":
                        system.win = "2000";
                        break;
                    case "5.1":
                        system.win = "XP";
                        break;
                    case "6.0":
                        system.win = "Vista";
                        break;
                    case "6.1":
                        system.win = "7";
                        break;
                    default:
                        system.win = "NT";
                        break;
                }
            } else if (RegExp["$1"] == "9x") {
                system.win = "ME";
            } else {
                system.win = RegExp["$1"];
            }
        }
    }

    // mobile devices
    system.iphone = ua.indexOf("iPhone") > -1;
    system.ipod = ua.indexOf("iPod") > -1;
    system.ipad = ua.indexOf("iPad") > -1;
    system.nokiaN = ua.indexOf("NokiaN") > -1;

    // windows mobile
    if (system.win == "CE") {
        system.winMobile = system.win;
    } else if ( system.win == "Ph") {
        if(/Windows Phone OS (\d+.\d+)/.test(ua)) {
            system.win = "Phone";
            system.winMobile = parseFloat(RegExp["$1"]);
        }
    }
    // determine iOS version
    if (system.mac && ua.indexOf("Mobile") > -1) {
        if(/CPU (?:iPhone )?OS (\d+_\d+)/.test(ua)) {
            system.ios = parseFloat(RegExp.$1.replace("_","."));
        } else {
            system.ios = 2;
        }
    }

    // determine Android version
    if (/Android (\d+\.\d+)/.test(ua)) {
        system.android = parseFloat(RegExp.$1);
    }

    // gaming systems
    system.wii = ua.indexOf("Wii") > -1;
    system.ps = /playstation/i.test(ua);

    // return it
    return {
        engine: engine,
        browser: browser,
        system: system
    };

}();

/**
 * Insert text into tags
 * either textContent or innerText
 * @param element
 */
function getInnerText(element)
{
    return (typeof element.textContent == "string") ?
            element.textContent : element.innerText;
}
function setInnerText(element, text)
{
    if(typeof element.textContent == "string")
    {
        element.textContent = text;
    }
    else
    {
        element.innerText = text;
    }
}

/**
 * Get the style sheet for the first <link/> element
 * @param element
 * return sheet
 */
function getStyleSheet(element)
{
  return element.sheet || element.styleSheet;
}

/**
 * Add rule for css
 * @param sheet
 * @param selectorText
 * @param cssText
 * @param position
 */
function insertRule(sheet, selectorText, cssText, position)
{
    if(sheet.insertRule)
    {
        sheet.insertRule(selectorText + "{" + cssText + "}", position);
    }
    else if(sheet.addRule)
    {
        sheet.addRule(selectorText, cssText, position);
    }
}

/**
 * Delete rule from style sheet
 * @param sheet
 * @param index
 */
function deleteRule(sheet, index)
{
  if(sheet.deleteRule)
  {
    sheet.deleteRule(index);
  }
  else if(sheet.removeRule)
  {
    sheet.removeRule(index);
  }
}

/**
 * Define left offset
 * @param element
 */
function getElementLeft(element)
{
    var actualLeft = element.offsetLeft;
    var current = element.offsetParent;

    while(current !== null)
    {
        actualLeft += current.offsetLeft;
        current = current.offsetParent;
    }
    return actualLeft;
}

/**
 * Define top offset
 * @param element
 */
function getElementTop(element)
{
    var actualTop = element.offsetTop;
    var current = element.offsetParent;

    while(current !== null)
    {
        actualTop += current.offsetTop;
        current = current.offsetParent;
    }
    return actualTop;
}

/**
 * Dimension of viewport
 * size of window(<html> or <body> elements)
 */
function getViewport()
{
    if(document.compatMode == "BackCompat")
    {
        return {
            width: document.body.clientWidth,
            height: document.body.clientHeight
        };
    }
    else
    {
        return {
            width: document.documentElement.clientWidth,
            height: document.documentElement.clientHeight
        };
    }
}


/**
 * Determine element dimensions
 * @param element
 */
function getBoundingClientRect(element)
{
    var scrollTop = document.documentElement.scrollTop;
    var scrollLeft = document.documentElement.scrollLeft;
    if(element.getBoundingClientRect)
    {
        if(typeof arguments.callee.offset != "number")
        {
            var scrollTop = document.documentElement.scrollTop;
            var temp = document.createElement("div");
            temp.style.cssText = "position:absolute;left:0;top:0;";
            document.body.appendChild(temp);
            arguments.callee.offset = -temp.getBoundingClientRect().top - scrollTop;
            document.body.removeChild(temp);
            temp = null;
        }
        var rect = element.getBoundingClientRect();
        var offset = arguments.callee.offset;

        return {
            left: rect.left + offset,
            right: rect.right + offset,
            top: rect.top + offset,
            bottom: rect.bottom + offset
        };
    }
    else
    {
        var actualLeft = getElementLeft(element);
        var actualTop = getElementTop(element);

        return {
            left: actualLeft - scrollLeft,
            right: actualLeft + element.offsetWidth - scrollLeft,
            top: actualTop - scrollTop,
            bottom: actualTop + element.offsetHeight - scrollTop
        }
    }
}

/**
 *  Retrieving Selected Text
 * @param textbox
 */
function getSelectedText(element)
{
    if(typeof element.selectionStart == "number")
    {
        return element.value.substring(element.selectionStart, element.selectionEnd);
    }
    else if(document.selection)
    {
        return document.selection.createRange().text;
    }
}

/**
 *  Retrieving Selected Text - crossbrowser
 * @param textbox
 */
function selectText(textbox, startIndex, stopIndex)
{
    if(textbox.setSelectionRange)
    {
        textbox.setSelectionRange(startIndex, stopIndex);
    }
    else if(textbox.createTextRange)
    {
        var range = textbox.createTextRange();
        range.collapse(true);
        range.moveStart("character", startIndex);
        range.moveEnd("character", stopIndex - startIndex);
        range.select();
    }
    textbox.focus();
}

/**
 * Console logging
 * @param message
 */
function consoleLog(message)
{
   if(typeof console == "object")
   {
       console.log(message);
   }
   else if(typeof opera == "object")
   {
       opera.postError(message);
   }
   else if(typeof java == "object" && typeof java.lang == "object")
   {
       java.lang.System.out.println(message);
   }
}

/**
 * Page logging
 * @param message
 */
function pageLog(message)
{
   var console = document.getElementById("droptarget");
   if(console === null)
   {
       console = document.createElement("div");
       console.id = "debuginfo";
       console.style.background = "#dedede";
       console.style.border = "1px solid silver";
       console.style.padding = "5px";
       console.style.width = "400px";
       console.style.position = "absolute";
       console.style.right = "0px";
       console.style.top = "0px";
       document.body.appendChild(console);
   }
   console.innerHTML += "<p>"+ message +"</p>";
}














/**
 * Closure, bind function with context(to use "this" for property in object)
 * Function binding involves creating a function
 * that calls another function with a specific this value
 * and with specific arguments. This technique is often used
 * in conjunction with callbacks and event handlers
 * to preserve code execution context while passing functions around
 * as variables
 * @param fn
 * @param context
 */
function bind(fn, context)
{
  return function()
  {
    return fn.apply(context, arguments);
  };
}

/**
 * Chunking array
 * @param array
 * @param process
 * @param context
 */
function chunk(array, process, context)
{
  setTimeout(function()
  {
    //get next item and process it
    var item = array.shift();
    process(item);
    
    //if there’s more items, set another timeout
    if(array.length > 0)
    {
      setTimeout(arguments.callee, 100);
    }
  }, 100);
}


/**
 * Use for resize event to decrease browser calculations
 * like singltone
 * @param method
 * @param context
 */
function throttle(method, context)
{
  clearTimeout(method.tId);
  method.tId = setTimeout(function()
  {
    method.call(context);
  }, 100);
}


function inheritPrototype(subType, superType)
{
  var prototype = Object(superType.prototype);
  prototype.constructor = subType;
  subType.prototype = prototype;
}


/**
 * Pattern custom events
 */
function EventTarget()
{
  this.handlers = {};
}

EventTarget.prototype =
{
  constructor: EventTarget,

  addHandler: function(type, handler)
  {
    if(typeof this.handlers[type] == "undefined")
    {
      this.handlers[type] = [];
    }

    this.handlers[type].push(handler);
  },


  fire: function(event)
  {
    if(!event.target)
    {
      event.target = this;
    }
    if(this.handlers[event.type] instanceof Array)
    {
      var handlers = this.handlers[event.type];
      for(var i=0, len=handlers.length; i < len; i++)
      {
        handlers[i](event);
      }
    }
  },

  removeHandler: function(type, handler)
  {
    if(this.handlers[type] instanceof Array)
    {
      var handlers = this.handlers[type];
      for(var i=0, len=handlers.length; i < len; i++)
      {
        if(handlers[i] === handler)
        {
          break;
        }
      }
      handlers.splice(i, 1);
    }
  }
};


/**
 * Drag and Drop
 */
var DragDrop = function()
{
  var dragging = null,
      diffX = 0,
      diffY = 0;

  function handleEvent(event)
  {
    event = EventUtil.getEvent(event);
    var target = EventUtil.getTarget(event);

    switch(event.type)
    {
      case "mousedown":
        if(target.className.indexOf("draggable") > -1)
        {
          dragging = target;
          diffX = event.clientX - target.offsetLeft;
          diffY = event.clientY - target.offsetTop;
        }
      break;

      case "mousemove":
        if(dragging !== null)
        {
          dragging.style.left = event.clientX - diffX + "px";
          dragging.style.top = event.clientY - diffY + "px";
        }
      break;

      case "mouseup":
        dragging = null;
      break;
    }
  }

  //public interface


    return {
      enable: function()
      {
        EventUtil.addHandler(document, "mousedown", handleEvent);
        EventUtil.addHandler(document, "mousemove", handleEvent);
        EventUtil.addHandler(document, "mouseup", handleEvent);
      },


      disable: function()
      {
        EventUtil.removeHandler(document, "mousedown", handleEvent);
        EventUtil.removeHandler(document, "mousemove", handleEvent);
        EventUtil.removeHandler(document, "mouseup", handleEvent);
      }
    }
}();


/**
 * Drag and Drop with event handlers: start, drag, stop
 * @type {DragDrop}
 */
var DragDrop = function(){
    var dragdrop = new EventTarget(),
        dragging = null,
        diffX = 0,
        diffY = 0;

    function handleEvent(event){

        event = event ? event : window.event;
        var target = event.target ? event.target : event.srcElement;
        switch(event.type){
            case "mousedown":
                if(target.className.indexOf("draggable") > -1){
                    dragging = target;
                    diffX = event.clientX - target.offsetLeft;
                    diffY = event.clientY - target.offsetTop;
                    dragdrop.fire({type:"dragstart", target: dragging,
                        x:event.clientX, y:event.clientY});
                }
                break;
            case "mousemove":
                if(dragging !== null){
                    dragging.style.left = (event.clientX - diffX) + "px";
                    dragging.style.top = (event.clientY - diffY) + "px";
                    dragdrop.fire({type:"drag", target: dragging,
                        x:event.clientX, y:event.clientY});
                }
                break;
            case "mouseup":
                if(dragging !== null){
                    dragdrop.fire({type:"dragend",target:dragging,
                        x:event.clientX, y:event.clientY});
                    dragging = null;
                }
                break;
        }
    }


    dragdrop.enable = function(){
        EventUtil.addHandler(document, "mousedown", handleEvent);
        EventUtil.addHandler(document, "mousemove", handleEvent);
        EventUtil.addHandler(document, "mouseup", handleEvent);
    };
    dragdrop.disable = function(){
        EventUtil.removeHandler(document, "mousedown", handleEvent);
        EventUtil.removeHandler(document, "mousemove", handleEvent);
        EventUtil.removeHandler(document, "mouseup", handleEvent);
    };
    return dragdrop;
}();


DragDrop.addHandler("dragstart", function(event){
    var status = document.getElementById("status");
    status.innerHTML = "started dragging " + event.target.id;
});

DragDrop.addHandler("drag", function(event){
    var status = document.getElementById("status");
    status.innerHTML += "<br />Dragged " + event.target.id + " to ("
        + event.x + "," + event.y + ")";
});

DragDrop.addHandler("dragend",function(event){
    var status = document.getElementById("status");
    status.innerHTML += "<br />Dropped " + event.target.id + " at ("
        + event.x + "," + event.y + ")";
});

//DragDrop.enable();




/**
 * Parse query string
 * return object with entire for each argument
 * @returns {{}}
 */
function getQueryStringArgs(){
    // Получаем строку запроса без ?
    var qs = (location.search.length > 0 ? location.search.substring(1) : ""),
        // Объект для хранения данных
        args = {},
        // Получаем отдельные части
        items = qs.length ? qs.split("&"): [],
        item = null,
        name = null,
        value = null,
        // Используем для цикла
        i = 0,
        len = items.length;
    // Сохраняем каждую часть в объект args, как args[name][value]
    for(i=0;i<len;i++){
        item = items[i].split("=");
        name = decodeURIComponent(item[0]);
        value = decodeURIComponent(item[1]);

        if(name.length){
            args[name] = value;
        }
    }
    return args;
}

/**
 * Detect Plugins over all browser except IE
 * @param name
 * @returns {boolean}
 */
function hasPlugin(name){
    name = name.toLowerCase();
    for(var i= 0,len = navigator.plugins.length; i<len;i++){
        if(navigator.plugins[i].name.toLowerCase().indexOf(name) > -1){
            return true;
        }
    }
    return false;
}
/**
 * Detect Plugins over IE
 * @param name
 * @returns {boolean}
 */
function hasIEPlugin(name){
    try{
        new ActiveXObject(name);
        return true;
    } catch (ex){
        return false;
    }
}


/**
 * Convert node.childNodes to array()
 * @param nodes
 * @returns array
 */
function convertToArray(nodes){
    var array = null;
    try {
        array = Array.prototype.slice.call(nodes, 0);
    } catch(ex) {
        array = new Array();
        for(var i= 0, len=nodes.length; i<len; i++){
            array.push(nodes[i]);
        }
    }
    return array;
}

/**
 * Используется для сериализации атрибутов в элементе
 * в XML
 * Function iterates over each attribute on an element and constructs a string in the format
 * name=“value” name=“value”
 * @param element
 * @returns {string}
 */
function outputAttributes(element){
    var pairs = new Array(),
        attrName,
        attrValue,
        i,
        len;

    for(i=0,len=element.attributes.length;i<len;i++){
        attrName = element.attributes[i].nodeName;
        attrValue = element.attributes[i].nodeValue;
        if(element.attributes[i].specified == true){
            pairs.push(attrName+"=\""+attrValue+"\"");
        }
    }
    return pairs.join(" ");
}



/**
 * Create table
 */
//var table = document.createElement("table");
//table.border = 1;
//table.width = "100%";
//
//var tbody = document.createElement("tbody");
//table.appendChild(tbody);
//
//tbody.insertRow(0);
//tbody.rows[0].insertCell(0);
//tbody.rows[0].cells[0].appendChild(document.createTextNode("Cell_1,1"));
//tbody.rows[0].insertCell(1);
//tbody.rows[0].cells[1].appendChild(document.createTextNode("Cell_2,1"));
//
//tbody.insertRow(1);
//tbody.rows[1].insertCell(0);
//tbody.rows[1].cells[0].appendChild(document.createTextNode("Cell_2,1"));
//tbody.rows[1].insertCell(1);
//tbody.rows[1].cells[1].appendChild(document.createTextNode("Cell_2,2"));

//document.body.appendChild(table);


/**
 * Scroll element into view
 */
//document.forms[0].scrollIntoView()


/**
 * Меняет фокус с одного элемента управления на другой
 * в зависимости от количества символов в нем
 * @param event
 */
function tabForward(event){
    event = event || window.event;
    var target = event.target || event.srcElement;

    if(target.value.length == target.maxLength){
        var form = target.form;

        for(var i = 0,len = form.elements.length; i < len; i++){
            if(form.elements[i] == target){
                if(form.elements[i+1]){
                    form.elements[i+1].focus();
                }
                return;
            }
        }
    }
}

/**
 * Функция для определения выделенного элемента в <select></select>
 * @param selectbox
 * @returns {Array}
 */
function getSelectedOptions(selectbox){
    var result = new Array();
    var option = null;

    for(var i= 0, len=selectbox.options.length; i < len; i++){
        option = selectbox.options[i];
        if(option.selected){
            result.push(option);
        }
    }
    return result;
}


/**
 * Сериализация формы ключ значения формы
 * @param form
 * @returns {string}
 */
function serializeForm(form){
    var parts = [],
        field = null,
        i,
        len,
        j,
        optLen,
        option,
        optValue;

    for(i=0,len = form.elements.length; i<len; i++){
        field = form.elements[i];

        switch(field.type){
            case "select-one":
            case "select-multiple":
                if(field.name.length){
                    for(j=0,optLen=field.options.length; j<optLen; j++){
                        option = field.options[j];
                        if(option.selected){
                            optValue = "";
                            if(option.hasAttribute){
                                optValue = (option.hasAttribute("value") ?
                                    option.value : option.text);
                            } else {
                                optValue = (option.attributes["value"].specified ?
                                    option.value : option.text);
                            }
                            parts.push(encodeURIComponent(field.name) + "=" +
                                encodeURIComponent(optValue));
                        }
                    }
                }
                break;
            case "undefined":
            case "file":
            case "submit":
            case "reset":
            case "button":
                break;
            case "radio":
            case "checkbox":
                if(!field.checked){
                    break;
                }
            default:
                if(field.name.length){
                    parts.push(encodeURIComponent(field.name) + "=" +
                        encodeURIComponent(field.value));
                }
        }
    }
    return parts.join("&");
}

/**
 * Кроссбраузерная функция для javascript console
 * @param message
 */
function log(message){
    if(typeof console == "object"){
        console.log(message);
    } else if (typeof opera == "object"){
        opera.postError(message);
    } else if (typeof java == "object" && typeof java.lang == "object"){
        java.lang.System.out.println(message);
    }
}


/**
 * page-loggin
 * @param message
 */
function log2(message){
    var console = document.getElementById("debuginfo");
    if(console === null){
        console = document.createElement("div");
        console.id = "degubinfo";
        console.style.background = "#dedede";
        console.style.border = "1px solid silver";
        console.style.padding = "5px";
        console.style.width = "400px";
        console.style.position = "absolute";
        console.style.right = "0px";
        console.style.top = "0px";
        document.body.appendChild(console);
    }
    console.innerHTML = "<p>" + message + "</p>";
}


/**
 * Error logging
 * @param condition
 * @param message
 */
function assert(condition, message){
    if(!condition){
        throw new Error(message);
    }
}


function getQueryString(url){
    if(typeof url == "string"){
        var pos = url.indexOf("?");
        if(pos == -1){
            return url.substring(pos+1);
        }
    }
    return "";
}


function addQueryStringArg(url,name,value){
    if(url.indexOf("?") == -1){
        url += "?";
    } else {
        url += "&";
    }
    url += encodeURIComponent(name)+ "=" + encodeURIComponent(value);
    return url;
}

/**
 * Safe Type Detection
 * @param value
 * @returns {boolean}
 */
function isArray(value){
    return Object.prototype.toString.call(value) == "[object Array]";
}
function isFunction(value){
    return Object.prototype.toString.call(value) == "[object Function]";
}
function isRegExp(value){
    return Object.prototype.toString.call(value) == "[object RegExp]";
}

/**
 * Create queue of items to porcess, use timers to pull the next item to process,
 * process it, and then set another timer.
 * @param array
 * @param process
 * @param context
 */
function chunk(array,process,context){
    setTimeout(function(){
        var item = array.shift();
        process.call(context,item);

        if(array.length > 0){
            setTimeout(arguments.callee, 100);
        }
    }, 100);
}

























/**
 * Create xmldom parser for IE
 * helper function for parseXml(xml)
 * @returns {ActiveXObject}
 */
function createDocument(){
    if(typeof arguments.callee.activeXString != "string"){
        var versions = ["MSXML2.DOMDocument.6.0", "MSXML2.DOMDocument.3.0",
                "MSXML2.DOMDocument"],
            i,len;
        for(i=0,len=versions.length;i<len;i++){
            try{
                new ActiveXObject(versions[i]);
                arguments.callee.activeXString = versions[i];
                break;
            } catch (ex){
                log2(ex.message);
            }
        }
    }
    return new ActiveXObject(arguments.callee.activeXString);
}

/**
 * XML Parser
 * @param xml
 */
function parseXml(xml)
{
    var xmldom = null;

    if(typeof DOMParser != "undefined")
    {
        xmldom = (new DOMParser()).parseFromString(xml, "text/xml");
        var errors = xmldom.getElementsByTagName("parsererror");
        if(errors.length)
        {
            throw new Error("XML parsing error:" + errors[0].textContent);
        }
    }
    else if (typeof ActiveXObject() != "undefined")
    {
        xmldom = createDocument();
        xmldom.loadXml(xml);
        if(xmldom.parseError != 0)
        {
            throw new Error("XML parsing error: " + xmldom.parseError.reason);
        }

    }
    else
    {
        throw new Error("No XML parser available.");
    }
    return xmldom;
}

/**
 * XML Serialization
 * @param xmldom
 */
function serializeXml(xmldom)
{
    if(typeof XMLSerializer != "undefined")
    {
        return (new XMLSerializer()).serializeToString(xmldom);
    }
    else if(typeof xmldom.xml != "undefined")
    {
        return xmldom.xml;
    }
    else
    {
        throw new Error("Could not serialize XML DOM.");
    }
}


/**
 * Cross-Browser XPath
 * Function selectSingleNode(context,expression,namespace);
 * @param context
 * @param expression
 * @param namespace
 * @returns {*}
 */
function selectSingleNode(context, expression, namespace){
    var doc = (context.nodeType != 9 ? context.ownerDocument : context);

    if(typeof doc.evaluate != "undefined"){
        var nsresolver = null;
        if(namespace instanceof Object){
            nsresolver = function(prefix){
                return namespace[prefix];
            };
        }

        var result = doc.evaluate(expression, context, nsresolver,
            XPathResult.FIRST_ORDERED_NODE_TYPE, null);
        return (result !== null ? result.singleNodeValue : null);
    } else if (typeof context.selectSingleNode != "undefined"){
        if(namespace instanceof Object){
            var ns = "";
            for(var prefix in namespace){
                if(namespace.hasOwnProperty(prefix)){
                    ns += "xmlns:" + prefix + "='" + namespace[prefix] + "' ";
                }
            }
            doc.setProperty("SelectionNamespaces", ns);
        }
        return context.selectSingleNode(expression);
    } else {
        throw new Error("No XPath engine found.");
    }
}


/**
 * Cross-Browser XPath
 * Function selectNodes(context,expression,namespace);
 * @param context
 * @param expression
 * @param namespaces
 * @returns {Array}
 */
function selectNodes(context, expression, namespaces){
    var doc = (context.nodeType != 9 ? context.ownerDocument : context);

    if(typeof doc.evaluate != "undefined"){
        var nsresolver = null;
        if(namespaces instanceof Object){
            nsresolver = function(prefix){
                return namespaces[prefix];
            };
        }

        var result = doc.evaluate(expression, context, nsresolver,
            XPathResult.ORDERED_NODE_SNAPSHOT_TYPE,
            null);
        var nodes = new Array();

        if(result !== null){
            for(var i= 0,len = result.snapshotLength; i<len; i++){
                nodes.push(result.snapshotItem(i));
            }
        }
        return nodes;
    } else if (typeof context.selectNode != "undefined"){
        if(namespaces instanceof Object){
            var ns = "";
            for(var prefix in namespaces){
                if(namespaces.hasOwnProperty(prefix)){
                    ns += "xmlns:"+prefix + "='" + namespaces[prefix] + "' ";
                }
            }
            doc.setProperty("SelectionNamespace", ns);
        }
        var result = context.selectNodes(expression);
        var nodes = new Array();

        for(var i= 0,len=result.length; i<len; i++){
            nodes.push(result[i]);
        }
        return nodes;
    }else {
        throw new Error("No XPath engine found.");

    }
}


/**
 * Load the XSLT style sheet into a thread-safe version of an XML document
 * @returns {ActiveXObject}
 */
function createThreadSafeDocument(){
    if(typeof arguments.callee.activeXString != "string"){
        var versions = ["MSXML2.FreeThreadDOMDocument.6.0",
                "MSXML2.FreeThreadDOMDocument.3.0",
                "MSXML2.FreeThreadDOMDocument"],
            i,
            len;

        for(i=0,len=versions.length;i<len;i++){
            try{
                new ActiveXObject(versions[i]);
                arguments.callee.activeXString = versions[i];
                break;
            } catch (ex){
                alert(ex.message);
            }
        }
    }
    return new ActiveXObject(arguments.callee.activeXString);
}


/**
 * Free-threaded DOM document is created and loaded(createThreadSafeDocument()), and it must be assigned to an XSL
 template
 * @returns {ActiveXObject}
 */
function createXSLTemplate(){
    if(typeof arguments.callee.activeXString != "string"){
        var versions = ["MSXML2.XSLTemplate.6.0",
                "MSXML2.XSLTemplate.3.0",
                "MSXML2.XSLTemplate"],
            i,
            len;

        for(i=0,len=versions.length; i<len; i++){
            try{
                new ActiveXObject(versions[i]);
                arguments.callee.activeXString = versions[i];
                break;
            } catch (ex) {
                alert(ex.message);
            }
        }
    }
    return new ActiveXObject(arguments.callee.activeXString);
}

/**
 * Cross-Browser XSLT
 * @param context
 * @param xslt
 * @returns {*}
 */
function transform(context, xslt){
    if(typeof XSLTProcessor != "undefined"){
        var processor = new XSLTProcessor();
        processor.importStylesheet(xslt);

        var result = processor.transformToDocument(context);
        return (new XMLSerializer()).serializeToString(result);
    } else if (typeof context.transformNode != "undefined"){
        return context.transformNode(xslt);
    } else {
        throw new Error("No XSLT processor available.");
    }
}












/**
 * CORS
 * @param method
 * @param url
 * return object XMLHttpRequestObject
 */
function createCORSRequest(method, url)
{
    var xhr = new XMLHttpRequest();
    if("withCredentials" in xhr)
    {
        xhr.open(method, url);
    }
    else if(typeof XDomainRequest != "undefined")
    {
        xhr = new XDomainRequest();
        xhr.open(method, url);
    }
    else
    {
        xhr = null;
    }
    return xhr;
}

/**
 * Lazy load function
 * Usual function XMLHttpRequest
 */
function createXHR(){
    if(typeof XMLHttpRequest != "undefined"){
        return new XMLHttpRequest();
    } else if(typeof ActiveXObject != "undefined"){
        if(typeof arguments.callee.activeXString != "string"){
            var versions = ["MSXML2.XMLHttp.6.0",
                    "MSXML2.XMLHttp.3.0",
                    "MSXML2.XMLHttp"],
                i,len;
            for(i=0,len=versions.length; i<len; i++){
                try{
                    new ActiveXObject(versions[i]);
                    arguments.callee.activeXString = versions[i];
                    break;
                } catch (ex){
                    alert(ex.message);
                }
            }
        }
        return new ActiveXObject(arguments.callee.activeXString);
    } else {
        throw new Error("No XHR object available");
    }
}

/**
 * Lazy load function
 * Invoke approach function XMLHttpRequest
 * @returns {*}
 */
function createXHRs(){
    if(typeof XMLHttpRequest != "undefined"){
        createXHRs = function(){
            return new XMLHttpRequest();
        };
    } else if(typeof ActiveXObject != "undefined"){
        createXHRs = function(){
            if(typeof arguments.callee.activeXString != "string"){
                var versions = ["MSXML2.XMLHttp.6.0",
                        "MSXML2.XMLHttp.3.0",
                        "MSXML2.XMLHttp"],
                    i,len;
                for(i=0, len=versions.length;i<len; i++){
                    try{
                        new ActiveXObject(versions[i]);
                        arguments.callee.activeXString = versions[i];
                        break;
                    } catch (ex){
                        alert(ex.message);
                    }
                }
            }
            return new ActiveXObject(arguments.callee.activeXString);
        };
    }else{
        createXHRs = function(){
            throw new Error("No XHR object available");
        };
    }
    return createXHRs();
}


/**
 * Anonymous invoke XMLHttpRequest
 */
var createXHR = (function(){
    if(typeof XMLHttpRequest != "undefined"){
        return function(){
            return new XMLHttpRequest();
        };
    }
    else if(typeof ActiveXObject != "undefined"){
        return function(){
            if(typeof arguments.callee.activeXString != "string"){
                var versions = ["MSXML2.XMLHttp.6.0",
                        "MSXML2.XMLHttp.3.0",
                        "MSXML2.XMLHttp"],
                    i,
                    len;
                for(i = 0, len = versions.length; i < len; i++){
                    try{
                        new ActiveXObject(versions[i]);
                        arguments.callee.activeXString = versions[i];
                        break;
                    }
                    catch(ex){
                        alert(ex.message);
                    }
                }
            }
            return new ActiveXObject(arguments.callee.activeXString);
        };
    }
    else{
        return function(){
            throw new Error("No XHR object available.");
        };
    }
})();









