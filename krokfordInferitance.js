    // Простой вспомогательный метод, позволяющий привязать новую функцию к
    // прототиу объекта
    Function.prototype.method = function(name, func)
    {
        this.prototype[name] = func;
        return this;
    };

    // Довольно сложная функция, позволяюющая весьма изящно наследовать
    // функции из других объектов, и сохраниять возможность вызова функции
    // "родительского" объекта
    Function.method('inherits', function(parent)
    {
        // Отслеживание, на каком уровне углубления в родителские функции мы
        // находимся
        var depth = {};

        // Наследование родительских методов
        var proto = (this.prototype = new parent());

        // Создание новой "привилегированной" функции под названием "uber",
        // которая при вызове выполняет любую функцию, вписанную
        // в наследование
        this.method('uber', function uber(name)
        {
            if(!(name in depth))
            {
                depth[name] = 0;
            }
            var func;   // исполняемая функция
            var ret;    // возвращение значение функции
            var t = depth[name];
            var v = parent.prototype;   // родительский прототип

            // Если ты уже находимся внутри другой функции 'uber'
            if(t)
            {
                while(t)
                {
                    v = v.constructor.prototype;
                    t -= 1;
                }
                // и получение функции из прототипа
                func = v[name];
            // А если это первый вызов 'uber'
            }
            else
            {
                // получение выполняемой функции из прототипа
                func = proto[name];

                // Если функция было частью этого прототипа
                if(func == this[name])
                {
                    // переход вместо этого к родителскому прототпипу
                    func = v[name];
                }
            }

            // Отслеживание той глубины, на которой мы находимся в стеке
            // наследования
            depth[name] += 1;

            // Вызов выполняемой функции со всеми аргументами, кроме первого
            // (в котором хранится имя исполняемой функции)
            ret = func.apply(this, Array.prototype.slice.apply(arguments,[1]));

            // Сброс глубины стека
            depth[name] -= 1;

            // Возвращение значения, возвращаемого выполняемой функцией
            return ret;
        });
        return this;
    });

    // Функция для наследования только двух функций из родительского
    // объекта, но не каждой функции, использующей new parent()
    Function.method('swiss', function(parent)
    {
        // Перебор всех наследуемых методов
        for(var i = 1; i < arguments.length; i += 1)
        {
            // Имя импортируемого метода
            var name = arguments[i];

            // Импорт метода в прототип этого объекта
            this.prototype[name] = parent.prototype[name];
        }
        return this;
    });